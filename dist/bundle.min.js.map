{"version":3,"file":"bundle.min.js","sources":["../node_modules/ivi/dist/client/core.js","../node_modules/udsv/dist/uDSV.mjs","../node_modules/uexpr/src/uExpr.mjs","../src/main.ts","../node_modules/ivi/dist/client/state.js"],"sourcesContent":["export const EMPTY_ARRAY = [];\n/**\n * Globally shared data is automatically generated by clientOptimizer plugin.\n */\nconst __IVI_DATA__ = /*@__IVI_DATA__*/ [];\n// Store global variables in a local scope as const variables so that JIT\n// compiler could easily inline functions and eliminate checks in case global\n// variables are overriden.\nconst _Object = Object;\nconst _Array = Array;\nconst _isArray = _Array.isArray;\nconst _Map = Map;\nconst _Int32Array = Int32Array;\nconst _queueMicrotask = queueMicrotask;\nconst _requestAnimationFrame = requestAnimationFrame;\nconst _requestIdleCallback = requestIdleCallback;\nconst nodeProto = Node.prototype;\nconst elementProto = Element.prototype;\nconst doc = document;\n// Template containers are used to create static templates from HTML strings\n// via `innerHTML`.\nconst HTM_TEMPLATE = /**@__PURE__*/ doc.createElement(\"template\");\nconst HTM_TEMPLATE_CONTENT = HTM_TEMPLATE.content;\nconst _SVG_TEMPLATE = /**@__PURE__*/ doc.createElement(\"template\");\nconst SVG_TEMPLATE = /**@__PURE__*/ doc.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n/**@__PURE__*/ _SVG_TEMPLATE.content.appendChild(SVG_TEMPLATE);\nconst SVG_TEMPLATE_CONTENT = _SVG_TEMPLATE.content.firstChild;\n// Store Node/Element methods to avoid going through a long prototype chain and\n// avoid megamorphic call-sites when accessing DOM nodes.\n/** `Node.prototype.insertBefore` */\nconst nodeInsertBefore = nodeProto.insertBefore;\n/** `Node.prototype.removeChild`. */\nconst nodeRemoveChild = nodeProto.removeChild;\n/** `Node.prototype.cloneNode`. */\nconst nodeCloneNode = nodeProto.cloneNode;\n/** `Element.prototype.setAttribute` */\nconst elementGetAttribute = elementProto.getAttribute;\n/** `Element.prototype.setAttribute` */\nconst elementSetAttribute = elementProto.setAttribute;\n/** `Element.prototype.removeAttribute` */\nconst elementRemoveAttribute = elementProto.removeAttribute;\n/** `EventTarget.prototype.addEventListener` */\nconst elementAddEventListener = elementProto.addEventListener;\n/** `EventTarget.prototype.removeEventListener` */\nconst elementRemoveEventListener = elementProto.removeEventListener;\n/** `Object.getOwnPropertyDescriptor(o, p)` */\nconst getDescriptor = (o, p) => _Object.getOwnPropertyDescriptor(o, p);\n/** `get Node.prototype.firstChild` */\nconst nodeGetFirstChild = /*@__PURE__*/ getDescriptor(nodeProto, \"firstChild\").get;\n/** `get Node.prototype.lastChild` */\nconst nodeGetLastChild = /*@__PURE__*/ getDescriptor(nodeProto, \"lastChild\").get;\n/** `get Node.prototype.nextSibling` */\nconst nodeGetNextSibling = /*@__PURE__*/ getDescriptor(nodeProto, \"nextSibling\").get;\n/** `get Node.prototype.previousSibling` */\nconst nodeGetPreviousSibling = /*@__PURE__*/ getDescriptor(nodeProto, \"previousSibling\").get;\n/** `set Node.prototype.textContent` */\nconst nodeSetTextContent = /*@__PURE__*/ getDescriptor(nodeProto, \"textContent\").set;\n/** `get Node.prototype.nodeType` */\nconst nodeGetNodeType = /*@__PURE__*/ getDescriptor(nodeProto, \"nodeType\").get;\n/** `set Element.prototype.innerHTML` */\nconst elementSetInnerHTML = /*@__PURE__*/ getDescriptor(elementProto, \"innerHTML\").set;\n/** `set Element.prototype.className` */\nconst elementSetClassName = /*@__PURE__*/ getDescriptor(elementProto, \"className\").set;\n/** `get HTMLElement.prototype.style`. */\nconst htmlElementGetStyle = /*@__PURE__*/ getDescriptor(HTMLElement.prototype, \"style\").get;\n/** `get SVGElement.prototype.style` */\nconst svgElementGetStyle = /*@__PURE__*/ getDescriptor(SVGElement.prototype, \"style\").get;\n// When object is sealed and stored in a const variable, JIT compiler can\n// eliminate object map(shape) checks when accessing its properties.\n/**\n * Global Render Context.\n */\nexport const RENDER_CONTEXT = _Object.seal({\n    p: null,\n    n: null,\n    si: 0,\n    e: [],\n});\n/**\n * Creates a Stateful Node instance.\n *\n * @param v VNode.\n * @returns {@link SNode} instance.\n */\nexport const createSNode = (f, v, c, p, s1) => ({ f, v, c, p, s1 });\nexport const _flushDOMEffects = () => {\n    const e = RENDER_CONTEXT.e;\n    if (e.length > 0) {\n        RENDER_CONTEXT.e = [];\n        for (let i = 0; i < e.length; i++) {\n            e[i]();\n        }\n    }\n};\nconst _updateTemplateProperties = (currentElement, opCodes, data, state, prevProps, nextProps, svg) => {\n    let style;\n    for (let i = 0; i < opCodes.length; i++) {\n        const op = opCodes[i];\n        const type = op & 7 /* PropOpCode.TypeMask */;\n        const dataIndex = op >> 9 /* PropOpCode.DataShift */;\n        if (type === 0 /* PropOpCode.SetNode */) {\n            currentElement = state[dataIndex];\n            style = void 0;\n        }\n        else {\n            const propsIndex = (op >> 3 /* PropOpCode.InputShift */) & 63 /* PropOpCode.Mask6 */;\n            const next = nextProps[propsIndex];\n            if (type === 4 /* PropOpCode.DiffDOMProperty */) {\n                const key = data[dataIndex];\n                if (prevProps === null) {\n                    if (next !== void 0) {\n                        currentElement[key] = next;\n                    }\n                }\n                else if (currentElement[key] !== next) {\n                    currentElement[key] = next;\n                }\n            }\n            else {\n                let prev;\n                if (prevProps !== null) {\n                    prev = prevProps[propsIndex];\n                }\n                if (prev !== next) {\n                    if (type === 1 /* PropOpCode.Common */) {\n                        if (dataIndex === 0 /* CommonPropType.ClassName */) {\n                            if (next !== \"\" && next != null && next !== false) {\n                                elementSetClassName.call(currentElement, next);\n                            }\n                            else if (prev !== \"\" && prev != null && prev !== false) {\n                                elementSetClassName.call(currentElement, \"\");\n                            }\n                        }\n                        else if (dataIndex === 1 /* CommonPropType.TextContent */) {\n                            if (next !== \"\" && next != null && next !== false) {\n                                if (prev == null || prev === \"\" || prev === false) {\n                                    nodeSetTextContent.call(currentElement, next);\n                                }\n                                else {\n                                    nodeGetFirstChild.call(currentElement).nodeValue = next;\n                                }\n                            }\n                            else if (prev != null && prev !== \"\" && prev !== false) {\n                                nodeSetTextContent.call(currentElement, \"\");\n                            }\n                        }\n                        else { // CommonPropType.InnerHTML\n                            if (next !== \"\" && next != null && next !== false) {\n                                elementSetInnerHTML.call(currentElement, next);\n                            }\n                            else if (prev !== \"\" && prev != null && prev !== false) {\n                                nodeSetTextContent.call(currentElement, \"\");\n                            }\n                        }\n                    }\n                    else if (type === 7 /* PropOpCode.Directive */) {\n                        next(currentElement);\n                    }\n                    else {\n                        const key = data[dataIndex];\n                        if (type === 2 /* PropOpCode.Attribute */) {\n                            if (next !== false && next != null) {\n                                elementSetAttribute.call(currentElement, key, next);\n                            }\n                            else if (prev !== false && prev != null) {\n                                elementRemoveAttribute.call(currentElement, key);\n                            }\n                        }\n                        else if (type === 3 /* PropOpCode.Property */) {\n                            currentElement[key] = next;\n                        }\n                        else if (type === 5 /* PropOpCode.Style */) {\n                            if (next !== false && next != null) {\n                                if (style === void 0) {\n                                    style = (svg === false)\n                                        ? htmlElementGetStyle.call(currentElement)\n                                        : svgElementGetStyle.call(currentElement);\n                                }\n                                style.setProperty(key, next);\n                            }\n                            else if (prev !== false && prev != null) {\n                                if (style === void 0) {\n                                    style = (svg === false)\n                                        ? htmlElementGetStyle.call(currentElement)\n                                        : svgElementGetStyle.call(currentElement);\n                                }\n                                style.removeProperty(key);\n                            }\n                        }\n                        else { // PropOpCode.Event\n                            if (prev != null && prev !== false) {\n                                elementRemoveEventListener.call(currentElement, key, prev);\n                            }\n                            if (next != null && next !== false) {\n                                elementAddEventListener.call(currentElement, key, next);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n};\nconst _assignTemplateSlots = (currentNode, opCodes, offset, endOffset, state) => {\n    const ctx = RENDER_CONTEXT;\n    while (true) {\n        const op = opCodes[offset++];\n        if (op & 1 /* StateOpCode.Save */) {\n            state[++ctx.si] = currentNode;\n        }\n        if (op & 2 /* StateOpCode.EnterOrRemove */) {\n            const enterOffset = op >> 3 /* StateOpCode.OffsetShift */;\n            // Enter offset is used to disambiguate between enter and remove\n            // operations. Remove operations will always have a 0 enterOffset.\n            if (enterOffset) { // Enter\n                _assignTemplateSlots(nodeGetFirstChild.call(currentNode), opCodes, offset, offset += enterOffset, state);\n            }\n            else { // Remove\n                // Remove operation implies that current node is always a comment node\n                // followed by a text node.\n                const commentNode = currentNode;\n                state[++ctx.si] = currentNode = nodeGetNextSibling.call(currentNode);\n                commentNode.remove();\n            }\n        }\n        if (offset === endOffset) {\n            return;\n        }\n        currentNode = nodeGetNextSibling.call(currentNode);\n    }\n};\nconst _mountList = (parentState, flags, children, vNode) => {\n    let i = children.length;\n    const sChildren = _Array(i);\n    const sNode = createSNode(flags, vNode, sChildren, parentState, null);\n    while (i > 0) {\n        sChildren[--i] = _mount(sNode, children[i]);\n    }\n    return sNode;\n};\nconst _updateArray = (parentSNode, sNode, next, updateFlags) => {\n    if (!_isArray(next)) {\n        _unmount(sNode, true);\n        return _mount(parentSNode, next);\n    }\n    const prevSChildren = sNode.c;\n    let nextSChildren = prevSChildren;\n    let prevLength = prevSChildren.length;\n    let nextLength = next.length;\n    if (nextLength !== prevLength) {\n        sNode.c = nextSChildren = _Array(nextLength);\n        while (prevLength > nextLength) {\n            const sChild = prevSChildren[--prevLength];\n            if (sChild !== null) {\n                _unmount(sChild, true);\n            }\n        }\n        while (nextLength > prevLength) {\n            nextSChildren[--nextLength] = _mount(sNode, next[nextLength]);\n        }\n    }\n    while (nextLength > 0) {\n        nextSChildren[--nextLength] = _update(sNode, prevSChildren[nextLength], next[nextLength], updateFlags);\n    }\n    return sNode;\n};\n/**\n * Updates a Stateful Node with a new Stateless Node.\n *\n * @param parentSNode Parent Stateul Node.\n * @param sNode Stateful Node to update.\n * @param next New Stateless Node.\n * @param updateFlags Update flags (ForceUpdate and DisplaceNode).\n * @returns Stateful Node.\n */\nconst _update = (parentSNode, sNode, next, updateFlags) => {\n    if (sNode === null) {\n        return _mount(parentSNode, next);\n    }\n    if (next === false || next == null || next === \"\") {\n        _unmount(sNode, true);\n        return null;\n    }\n    // polymorphic call-site\n    const children = sNode.c;\n    const prev = sNode.v;\n    const state = sNode.s1;\n    const flags = sNode.f;\n    const type = flags & 127 /* Flags.TypeMask */;\n    sNode.f = type;\n    // Reassign to reduce memory consumption even if next value is strictly\n    // equal to the prev value.\n    sNode.v = next;\n    // Text and Array should be checked before Component, Template and List\n    // because their stateless nodes are represented with basic string and array\n    // types.\n    if (type === 16 /* Flags.Text */) {\n        const ctx = RENDER_CONTEXT;\n        if (typeof next !== \"object\") {\n            if (prev !== next) {\n                state.nodeValue = next;\n            }\n            if (updateFlags & 1024 /* Flags.DisplaceNode */) {\n                nodeInsertBefore.call(ctx.p, state, ctx.n);\n            }\n            ctx.n = state;\n            return sNode;\n        }\n        nodeRemoveChild.call(ctx.p, state);\n        return _mount(parentSNode, next);\n    }\n    if (prev === next) {\n        _dirtyCheck(sNode, updateFlags);\n        return sNode;\n    }\n    // Dirty flags should be cleared after dirty checking.\n    sNode.f = type;\n    if (type === 8 /* Flags.Array */) {\n        return _updateArray(parentSNode, sNode, next, updateFlags);\n    }\n    const descriptor = next.d;\n    const nextProps = next.p;\n    const prevProps = prev.p;\n    if (prev.d !== descriptor) {\n        _unmount(sNode, true);\n        return _mount(parentSNode, next);\n    }\n    if (type === 2 /* Flags.Component */) {\n        if (((flags | updateFlags) & (128 /* Flags.Dirty */ | 512 /* Flags.ForceUpdate */)) ||\n            (descriptor.p2 === void 0) ||\n            (descriptor.p2(prevProps, nextProps) !== true)) {\n            sNode.c = _update(sNode, children, state(nextProps), updateFlags);\n        }\n        else if (children !== null) {\n            _dirtyCheck(children, updateFlags);\n        }\n    }\n    else if (type === 1 /* Flags.Template */) {\n        const ctx = RENDER_CONTEXT;\n        const parentElement = ctx.p;\n        const tplData = descriptor.p1;\n        const flags = tplData.f;\n        const data = tplData.d;\n        const propsOpCodes = tplData.p;\n        const childOpCodes = tplData.c;\n        const rootDOMNode = state[0];\n        if (updateFlags & 1024 /* Flags.DisplaceNode */) {\n            updateFlags ^= 1024 /* Flags.DisplaceNode */;\n            nodeInsertBefore.call(parentElement, rootDOMNode, ctx.n);\n        }\n        _updateTemplateProperties(rootDOMNode, propsOpCodes, data, state, prevProps, nextProps, !!(flags & 4096 /* TemplateFlags.Svg */));\n        if (children !== null) {\n            ctx.p = rootDOMNode;\n            ctx.n = null;\n            let childrenIndex = 0;\n            for (let i = 0; i < childOpCodes.length; i++) {\n                const childOpCode = childOpCodes[i];\n                const type = childOpCode & 3 /* ChildOpCode.Type */;\n                const value = childOpCode >> 2 /* ChildOpCode.ValueShift */;\n                if (type === 0 /* ChildOpCode.Child */) {\n                    children[childrenIndex] =\n                        _update(sNode, children[childrenIndex++], nextProps[value], updateFlags);\n                }\n                else if (type === 1 /* ChildOpCode.SetNext */) {\n                    ctx.n = state[value];\n                }\n                else { // ChildOpCode.SetParent\n                    ctx.p = state[value];\n                    ctx.n = null;\n                }\n            }\n            ctx.p = parentElement;\n        }\n        ctx.n = rootDOMNode;\n    }\n    else if (type === 4 /* Flags.List */) {\n        _updateList(sNode, prevProps, nextProps, updateFlags);\n    }\n    else { // Context\n        if (prevProps.v !== nextProps.v) {\n            updateFlags |= 512 /* Flags.ForceUpdate */;\n        }\n        sNode.c = _update(sNode, children, nextProps.c, updateFlags);\n    }\n    return sNode;\n};\n/**\n * Mounts Stateless Node.\n *\n * @param parentSNode Parent Stateful Node.\n * @param v Stateless Node.\n * @returns Mounted Stateful Node.\n */\nconst _mount = (parentSNode, v) => {\n    if (v !== false && v != null) {\n        if (typeof v === \"object\") {\n            if (_isArray(v)) {\n                return _mountList(parentSNode, 8 /* Flags.Array */, v, v);\n            }\n            else {\n                const descriptor = v.d;\n                const props = v.p;\n                const descriptorP1 = descriptor.p1;\n                const type = descriptor.f & (1 /* Flags.Template */ | 2 /* Flags.Component */ | 4 /* Flags.List */);\n                if (type === 1 /* Flags.Template */) {\n                    const ctx = RENDER_CONTEXT;\n                    const parentDOMElement = ctx.p;\n                    const nextDOMNode = ctx.n;\n                    const tplData = descriptorP1;\n                    const data = tplData.d;\n                    const propsOpCodes = tplData.p;\n                    const stateOpCodes = tplData.s;\n                    const childOpCodes = tplData.c;\n                    const flags = tplData.f;\n                    const rootDOMNode = descriptor.p2();\n                    const state = _Array(flags & 63 /* TemplateFlags.Mask6 */);\n                    state[0] = rootDOMNode;\n                    if (stateOpCodes.length > 0) {\n                        ctx.si = 0;\n                        _assignTemplateSlots(nodeGetFirstChild.call(rootDOMNode), stateOpCodes, 0, stateOpCodes.length, state);\n                    }\n                    _updateTemplateProperties(rootDOMNode, propsOpCodes, data, state, null, props, !!(flags & 4096 /* TemplateFlags.Svg */));\n                    const sNode = createSNode(1 /* Flags.Template */, v, null, parentSNode, state);\n                    if (childOpCodes.length > 0) {\n                        const children = _Array((flags >> 6 /* TemplateFlags.ChildrenSizeShift */) & 63 /* TemplateFlags.Mask6 */);\n                        sNode.c = children;\n                        ctx.p = rootDOMNode;\n                        ctx.n = null;\n                        let childrenIndex = 0;\n                        for (let i = 0; i < childOpCodes.length; i++) {\n                            const childOpCode = childOpCodes[i];\n                            const type = childOpCode & 3 /* ChildOpCode.Type */;\n                            const value = childOpCode >> 2 /* ChildOpCode.ValueShift */;\n                            if (type === 0 /* ChildOpCode.Child */) {\n                                children[childrenIndex++] = _mount(sNode, props[value]);\n                            }\n                            else if (type === 1 /* ChildOpCode.SetNext */) {\n                                ctx.n = state[value];\n                            }\n                            else { // ChildOpCode.SetParent\n                                ctx.p = state[value];\n                                ctx.n = null;\n                            }\n                        }\n                        ctx.p = parentDOMElement;\n                    }\n                    ctx.n = rootDOMNode;\n                    nodeInsertBefore.call(parentDOMElement, rootDOMNode, nextDOMNode);\n                    return sNode;\n                }\n                else if (type === 2 /* Flags.Component */) {\n                    const sNode = {\n                        f: 2 /* Flags.Component */,\n                        v: v,\n                        c: null,\n                        p: parentSNode,\n                        s1: null,\n                        s2: null,\n                    };\n                    const renderFn = descriptorP1(sNode);\n                    sNode.c = _mount(sNode, renderFn(props));\n                    sNode.s1 = renderFn;\n                    return sNode;\n                }\n                else if (type === 4 /* Flags.List */) {\n                    return _mountList(parentSNode, 4 /* Flags.List */, props.v, v);\n                }\n                // Context\n                const sNode = createSNode(64 /* Flags.Context */, v, null, parentSNode, null);\n                sNode.c = _mount(sNode, props.c);\n                return sNode;\n            }\n        }\n        else if (v !== \"\") { // text\n            const ctx = RENDER_CONTEXT;\n            const next = ctx.n;\n            const e = doc.createTextNode(v);\n            ctx.n = e;\n            nodeInsertBefore.call(ctx.p, e, next);\n            return createSNode(16 /* Flags.Text */, v, null, parentSNode, e);\n        }\n    }\n    return null;\n};\n/**\n * Performs a Dirty Checking in a Stateful Node Subtree.\n *\n * @param sNode Stateful Node.\n * @param updateFlags Update flags (ForceUpdate and DisplaceNode).\n */\nconst _dirtyCheck = (sNode, updateFlags) => {\n    const ctx = RENDER_CONTEXT;\n    // polymorphic call-site\n    const state = sNode.s1;\n    const v = sNode.v;\n    const children = sNode.c;\n    const flags = sNode.f;\n    const type = flags & 127 /* Flags.TypeMask */;\n    sNode.f = type;\n    if (type === 1 /* Flags.Template */) {\n        const rootDOMNode = state[0];\n        if (updateFlags & 1024 /* Flags.DisplaceNode */) {\n            updateFlags ^= 1024 /* Flags.DisplaceNode */;\n            nodeInsertBefore.call(ctx.p, rootDOMNode, ctx.n);\n        }\n        if (flags & 256 /* Flags.DirtySubtree */) {\n            ctx.p = rootDOMNode;\n            ctx.n = null;\n            const parentDOMElement = ctx.p;\n            const childOpCodes = v.d.p1.c;\n            let childrenIndex = 0;\n            for (let i = 0; i < childOpCodes.length; i++) {\n                const op = childOpCodes[i];\n                const type = op & 3 /* ChildOpCode.Type */;\n                const value = op >> 2 /* ChildOpCode.ValueShift */;\n                if (type === 0 /* ChildOpCode.Child */) {\n                    const sChild = children[childrenIndex++];\n                    if (sChild !== null) {\n                        _dirtyCheck(sChild, updateFlags);\n                    }\n                }\n                else if (type === 1 /* ChildOpCode.SetNext */) {\n                    ctx.n = state[value];\n                }\n                else { // ChildOpCode.SetParent\n                    ctx.p = state[value];\n                    ctx.n = null;\n                }\n            }\n            ctx.p = parentDOMElement;\n        }\n        ctx.n = rootDOMNode;\n    }\n    else if (type === 16 /* Flags.Text */) {\n        if (updateFlags & 1024 /* Flags.DisplaceNode */) {\n            nodeInsertBefore.call(ctx.p, state, ctx.n);\n        }\n        ctx.n = state;\n    }\n    else if (type === 2 /* Flags.Component */) {\n        if ((flags | updateFlags) & (128 /* Flags.Dirty */ | 512 /* Flags.ForceUpdate */)) {\n            sNode.c = _update(sNode, children, state(v.p), updateFlags);\n        }\n        else if (children !== null) {\n            _dirtyCheck(children, updateFlags);\n        }\n    }\n    else if (type === 64 /* Flags.Context */) {\n        if (children !== null) {\n            _dirtyCheck(children, updateFlags);\n        }\n    }\n    else { // Array || List\n        let i = children.length;\n        while (--i >= 0) {\n            const sChild = children[i];\n            if (sChild !== null) {\n                _dirtyCheck(sChild, updateFlags);\n            }\n        }\n    }\n};\n/**\n * Unmounts Stateful Node.\n *\n * @param sNode Stateful Node.\n * @param detach Detach root DOM nodes from the DOM.\n */\nconst _unmount = (sNode, detach) => {\n    const flags = sNode.f; // polymorphic call-site\n    const sChildren = sNode.c;\n    if (detach === true && (flags & (1 /* Flags.Template */ | 16 /* Flags.Text */))) {\n        detach = false;\n        nodeRemoveChild.call(RENDER_CONTEXT.p, (flags & 1 /* Flags.Template */)\n            ? sNode.s1[0]\n            : sNode.s1);\n    }\n    if (flags & 2 /* Flags.Component */) {\n        const unmountHooks = sNode.s2;\n        if (unmountHooks !== null) {\n            if (typeof unmountHooks === \"function\") {\n                unmountHooks();\n            }\n            else {\n                for (let i = 0; i < unmountHooks.length; i++) {\n                    unmountHooks[i]();\n                }\n            }\n        }\n    }\n    if (sChildren !== null) {\n        if (_isArray(sChildren)) {\n            for (let i = 0; i < sChildren.length; i++) {\n                const sChild = sChildren[i];\n                if (sChild !== null) {\n                    _unmount(sChild, detach);\n                }\n            }\n        }\n        else {\n            _unmount(sChildren, detach);\n        }\n    }\n};\n/**\n * Update children list with track by key algorithm.\n *\n * High-level overview of the algorithm that is implemented in this function:\n *\n * This algorithm finds a minimum number of DOM operations. It works in\n * several steps:\n *\n * 1. Common prefix and suffix optimization.\n *\n * Look for nodes with identical keys by simultaneously iterating through nodes\n * in the old children list `A` and new children list `B` from both sides.\n *\n *     A: -> [a b c d] <-\n *     B: -> [a b d] <-\n *\n * Skip nodes \"a\" and \"b\" at the start, and node \"d\" at the end.\n *\n *     A: -> [c] <-\n *     B: -> [] <-\n *\n * 2. Zero length optimizations.\n *\n * Check if the size of one of the list is equal to zero. When length of the\n * old children list is zero, insert remaining nodes from the new list. When\n * length of the new children list is zero, remove remaining nodes from the old\n * list.\n *\n *     A: -> [a b c g] <-\n *     B: -> [a g] <-\n *\n * Skip nodes \"a\" and \"g\" (prefix and suffix optimization).\n *\n *     A: [b c]\n *     B: []\n *\n * Remove nodes \"b\" and \"c\".\n *\n * 3. Index and unmount removed nodes.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *     P: [. . . . .] // . == -1\n *\n * Create array `P` (`sources`) with the length of the new children list and\n * fills it with `NewNodeMark` values. This mark indicates that node at this\n * position should be mounted. Later we will assign node positions in the old\n * children list to this array.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *     P: [. . . . .] // . == -1\n *     I: {\n *       c: 0, // B[0] == c\n *       b: 1, // B[1] == b\n *       h: 2,\n *       f: 3,\n *       e: 4,\n *     }\n *     last = 0\n *\n * Create reverse index `I` that maps keys to node positions in the new\n * children list.\n *\n *     A: [b c d e f]\n *         ^\n *     B: [c b h f e]\n *     P: [. 0 . . .] // . == -1\n *     I: {\n *       c: 0,\n *       b: 1, <-\n *       h: 2,\n *       f: 3,\n *       e: 4,\n *     }\n *     last = 1\n *\n * Assign original positions of the nodes from the old children list to the\n * array `P`.\n *\n * Iterate through nodes in the old children list and gets their new positions\n * from the index `I`. Assign old node position to the array `P`. When index\n * `I` doesn't have a key for the old node, it means that it should be\n * unmounted.\n *\n * When we assigning positions to the array `P`, we also store position of the\n * last seen node in the new children list `pos`, if the last seen position is\n * greater than the current position of the node at the new list, then we are\n * switching `rearrangeNodes` flag to `true` (`pos === RearrangeNodes`).\n *\n *     A: [b c d e f]\n *           ^\n *     B: [c b h f e]\n *     P: [1 0 . . .] // . == -1\n *     I: {\n *       c: 0, <-\n *       b: 1,\n *       h: 2,\n *       f: 3,\n *       e: 4,\n *     }\n *     last = 1 // last > 0; rearrangeNodes = true\n *\n * The last position `1` is greater than the current position of the node at the\n * new list `0`, switch `rearrangeNodes` flag to `true`.\n *\n *     A: [b c d e f]\n *             ^\n *     B: [c b h f e]\n *     P: [1 0 . . .] // . == -1\n *     I: {\n *       c: 0,\n *       b: 1,\n *       h: 2,\n *       f: 3,\n *       e: 4,\n *     }\n *     rearrangeNodes = true\n *\n * Node with key \"d\" doesn't exist in the index `I`, unmounts node `d`.\n *\n *     A: [b c d e f]\n *               ^\n *     B: [c b h f e]\n *     P: [1 0 . . 3] // . == -1\n *     I: {\n *       c: 0,\n *       b: 1,\n *       h: 2,\n *       f: 3,\n *       e: 4, <-\n *     }\n *     rearrangeNodes = true\n *\n * Assign position `3` for `e` node.\n *\n *     A: [b c d e f]\n *                 ^\n *     B: [c b h f e]\n *     P: [1 0 . 4 3] // . == -1\n *     I: {\n *       c: 0,\n *       b: 1,\n *       h: 2,\n *       f: 3, <-\n *       e: 4,\n *     }\n *     rearrangeNodes = true\n *\n * Assign position `4` for 'f' node.\n *\n * 4. Find minimum number of moves when `rearrangeNodes` flag is on and mount\n *    new nodes.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *     P: [1 * . 4 *] // . == -1  * == -2\n *\n * When `rearrangeNodes` is on, mark all nodes in the array `P` that belong to\n * the [longest increasing subsequence](http://en.wikipedia.org/wiki/Longest_increasing_subsequence)\n * and move all nodes that doesn't belong to this subsequence.\n *\n * Iterate over the new children list and the `P` array simultaneously. When\n * value from `P` array is equal to `NewNodeMark`, mount a new node. When it\n * isn't equal to `LisMark`, move it to a new position.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *                 ^  // new_pos == 4\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *                 ^\n *\n * Node \"e\" has `LisMark` value in the array `P`, nothing changes.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *               ^    // new_pos == 3\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *               ^\n *\n * Node \"f\" has `4` value in the array `P`, move it before the next node \"e\".\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *             ^      // new_pos == 2\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *             ^\n *\n * Node \"h\" has `NewNodeMark` value in the array `P`, mount new node \"h\".\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *           ^        // new_pos == 1\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *           ^\n *\n * Node \"b\" has `LisMark` value in the array `P`, nothing changes.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *         ^          // new_pos == 0\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *\n * Node \"c\" has `1` value in the array `P`, move it before the next node \"b\".\n *\n * When `rearrangeNodes` flag is off, skip LIS algorithm and mount nodes that\n * have `NewNodeMark` value in the array `P`.\n *\n * NOTE: There are many variations of this algorithm that are used by many UI\n * libraries and many implementations are still using an old optimization\n * technique that were removed several years ago from this implementation. This\n * optimization were used to improve performance of simple moves/swaps. E.g.\n *\n *     A: -> [a b c] <-\n *     B: -> [c b a] <-\n *\n * Move \"a\" and \"c\" nodes to the other edge.\n *\n *     A: -> [b] <-\n *     B: -> [b] <-\n *\n * Skip node \"b\".\n *\n * This optimization were removed because it breaks invariant that insert and\n * remove operations shouldn't trigger a move operation. E.g.\n *\n *     A: -> [a b]\n *     B:    [c a] <-\n *\n * Move node \"a\" to the end.\n *\n *     A: [b]\n *     B: [c a]\n *\n * Remove node \"b\" and insert node \"c\".\n *\n * In this use case, this optimization performs one unnecessary operation.\n * Instead of removing node \"b\" and inserting node \"c\", it also moves node \"a\".\n *\n * @param sNode {@link SList} node.\n * @param a Previous {@link ListProps}.\n * @param b Next {@link ListProps}.\n * @param updateFlags Update flags.\n * @noinline\n * @__NOINLINE__\n */\nconst _updateList = (sNode, a, b, updateFlags) => {\n    const aKeys = a.k;\n    const bKeys = b.k;\n    const bVNodes = b.v;\n    let bLength = bKeys.length;\n    let aLength = aKeys.length;\n    const result = _Array(bLength);\n    if (bLength === 0) { // New children list is empty.\n        if (aLength > 0) { // Unmount nodes from the old children list.\n            _unmount(sNode, true);\n        }\n    }\n    else if (aLength === 0) { // Old children list is empty.\n        while (bLength > 0) { // Mount nodes from the new children list.\n            result[--bLength] = _mount(sNode, bVNodes[bLength]);\n        }\n    }\n    else {\n        const sChildren = sNode.c;\n        let aEnd = aLength - 1;\n        let bEnd = bLength - 1;\n        let start = 0;\n        // Step 1\n        outer: while (true) {\n            // Update nodes with the same key at the end.\n            while (aKeys[aEnd] === bKeys[bEnd]) {\n                result[bEnd] = _update(sNode, sChildren[aEnd--], bVNodes[bEnd], updateFlags);\n                if (start > --bEnd || start > aEnd) {\n                    break outer;\n                }\n            }\n            // Update nodes with the same key at the beginning.\n            while (aKeys[start] === bKeys[start] && ++start <= aEnd && start <= bEnd) {\n                // delayed update (all updates should be performed from right-to-left).\n            }\n            break;\n        }\n        // Step 2\n        if (start > aEnd) {\n            // All nodes from `a` are updated, insert the rest from `b`.\n            while (bEnd >= start) {\n                result[bEnd] = _mount(sNode, bVNodes[bEnd--]);\n            }\n        }\n        else if (start > bEnd) {\n            // All nodes from `b` are updated, remove the rest from `a`.\n            bLength = start;\n            do {\n                const sChild = sChildren[bLength++];\n                if (sChild !== null) {\n                    _unmount(sChild, true);\n                }\n            } while (bLength <= aEnd);\n        }\n        else { // Step 3\n            let bLength = bEnd - start + 1;\n            const sources = new _Int32Array(bLength); // Maps positions in the new children list to positions in the old list.\n            const keyIndex = new _Map(); // Maps keys to their positions in the new children list.\n            for (let i = 0; i < bLength; i++) {\n                // `NewNodeMark` value indicates that node doesn't exist in the old children list.\n                sources[i] = -1 /* MagicValues.NewNodeMark */;\n                const j = start + i;\n                keyIndex.set(bKeys[j], j);\n            }\n            // When `nodePosition === RearrangeNodes`, it means that one of the nodes is in the wrong position and we should\n            // rearrange nodes with LIS-based algorithm `markLIS()`.\n            let nodePosition = 0;\n            for (let i = start; i <= aEnd; i++) {\n                const sChild = sChildren[i];\n                const nextPosition = keyIndex.get(aKeys[i]);\n                if (nextPosition !== void 0) {\n                    nodePosition = (nodePosition < nextPosition)\n                        ? nextPosition\n                        : 1073741823 /* MagicValues.RearrangeNodes */;\n                    sources[nextPosition - start] = i;\n                    result[nextPosition] = sChild;\n                }\n                else if (sChild !== null) {\n                    _unmount(sChild, true);\n                }\n            }\n            // Step 4\n            // Mark LIS nodes only when this node weren't moved `moveNode === false` and we've detected that one of the\n            // children nodes were moved `pos === MagicValues.MovedChildren`.\n            if (!(updateFlags & 1024 /* Flags.DisplaceNode */) && nodePosition === 1073741823 /* MagicValues.RearrangeNodes */) {\n                markLIS(sources);\n            }\n            while (bLength-- > 0) {\n                bEnd = bLength + start;\n                const node = bVNodes[bEnd];\n                const lisValue = sources[bLength];\n                result[bEnd] = (lisValue === -1)\n                    ? _mount(sNode, node)\n                    : _update(sNode, result[bEnd], node, updateFlags |\n                        ((nodePosition === 1073741823 /* MagicValues.RearrangeNodes */ && lisValue !== -2 /* MagicValues.LISMark */)\n                            ? 1024 /* Flags.DisplaceNode */\n                            : 0));\n            }\n        }\n        // Delayed update for nodes from Step 1 (prefix only). Reconciliation algorithm always updates nodes from right to\n        // left.\n        while (start > 0) {\n            result[--start] = _update(sNode, sChildren[start], bVNodes[start], updateFlags);\n        }\n    }\n    sNode.c = result;\n};\n/**\n * Modified Longest Increased Subsequence algorithm.\n *\n * Mutates input array `a` and replaces all values that are part of LIS with -2 value.\n *\n * Constraints:\n * - Doesn't work with negative numbers. -1 values are ignored.\n * - Input array `a` should contain at least one value that is greater than -1.\n *\n * {@link http://en.wikipedia.org/wiki/Longest_increasing_subsequence}\n *\n * @example\n *\n *     const A = Int32Array.from([-1, 0, 2, 1]);\n *     markLIS(A);\n *     // A => [-1, -2, 2, -2]\n *\n * @param a Array of numbers.\n * @noinline\n * @__NOINLINE__\n */\nconst markLIS = (a) => {\n    const length = a.length;\n    const parent = new _Int32Array(length);\n    const index = new _Int32Array(length);\n    let indexLength = 0;\n    let i = 0;\n    let j;\n    let k;\n    let lo;\n    let hi;\n    // Skip -1 values at the start of the input array `a`.\n    for (; a[i] === -1 /* MagicValues.NewNodeMark */; i++) { /**/ }\n    index[0] = i++;\n    for (; i < length; i++) {\n        k = a[i];\n        if (k !== -1 /* MagicValues.NewNodeMark */) { // Ignore -1 values.\n            j = index[indexLength];\n            if (a[j] < k) {\n                parent[i] = j;\n                index[++indexLength] = i;\n            }\n            else {\n                lo = 0;\n                hi = indexLength;\n                while (lo < hi) {\n                    j = (lo + hi) >> 1;\n                    if (a[index[j]] < k) {\n                        lo = j + 1;\n                    }\n                    else {\n                        hi = j;\n                    }\n                }\n                if (k < a[index[lo]]) {\n                    if (lo > 0) {\n                        parent[i] = index[lo - 1];\n                    }\n                    index[lo] = i;\n                }\n            }\n        }\n    }\n    ;\n    // Mutate input array `a` and assign -2 value to all nodes that are part of LIS.\n    j = index[indexLength];\n    while (indexLength-- >= 0) {\n        a[j] = -2 /* MagicValues.LISMark */;\n        j = parent[j];\n    }\n};\n/**\n * Creates a HTML Template cloning factory.\n */\nexport const _h = (t) => (() => {\n    if (typeof t === \"string\") {\n        HTM_TEMPLATE.innerHTML = t;\n        t = HTM_TEMPLATE_CONTENT.firstChild;\n    }\n    return nodeCloneNode.call(t, true);\n});\n/**\n * Creates a HTML Template factory.\n */\nexport const _hN = (t) => (() => (HTM_TEMPLATE.innerHTML = t,\n    HTM_TEMPLATE_CONTENT.firstChild));\n/**\n * Creates a HTML Element factory.\n */\nexport const _hE = (t) => (() => doc.createElement(t));\n/**\n * Creates a SVG Template cloning factory.\n */\nexport const _s = (t) => (() => {\n    if (typeof t === \"string\") {\n        SVG_TEMPLATE.innerHTML = t;\n        t = SVG_TEMPLATE_CONTENT.firstChild;\n    }\n    return nodeCloneNode.call(t, true);\n});\n/**\n * Creates a SVG Template factory.\n */\nexport const _sN = (t) => (() => (SVG_TEMPLATE.innerHTML = t,\n    SVG_TEMPLATE_CONTENT.firstChild));\n/**\n * Creates a SVG Element factory.\n */\nexport const _sE = (t) => (() => doc.createElementNS(\"http://www.w3.org/2000/svg\", t));\n/**\n * Creates a template descriptor with globally shared data.\n */\nexport const _T = (p2, f, p, c, s) => ({\n    f: 1 /* Flags.Template */,\n    p1: { f, p, c, s, d: __IVI_DATA__ },\n    p2,\n});\n/**\n * Creates a template descriptor.\n */\nexport const _Td = (p2, f, p, c, s, d) => ({\n    f: 1 /* Flags.Template */,\n    p1: { f, p, c, s, d },\n    p2,\n});\nexport const _t = (d, p) => ({ d, p });\n/**\n * Creates a factory that produces component nodes.\n *\n * @typeparam P Property type.\n * @param factory Function that produces stateful render functions.\n * @param areEqyal Function that checks `props` for equality.\n * @returns Factory that produces component nodes.\n */\nexport const component = (p1, p2) => {\n    const d = { f: 2 /* Flags.Component */, p1, p2 };\n    return (p) => ({ d, p });\n};\n/**\n * Gets current component props.\n *\n * @typeparam P Property type.\n * @param component Component node.\n * @returns Current component props.\n */\nexport const getProps = (component) => (component.v.p);\n/**\n * Adds an unmount hook.\n *\n * @example\n *\n *     const Example = component((c) => {\n *       useUnmount(c, () => { console.log(\"unmounted\"); });\n *\n *       return () => null;\n *     });\n *\n * @param component Component instance.\n * @param hook Unmount hook.\n */\nexport const useUnmount = (component, hook) => {\n    const hooks = component.s2;\n    component.s2 = (hooks === null)\n        ? hook\n        : (typeof hooks === \"function\")\n            ? [hooks, hook]\n            : (hooks.push(hook), hooks);\n};\n/**\n * Creates a side effect hook.\n *\n * @example\n *\n *     const Example = component((c) => {\n *       const [count, setCount] = useState(c, 0);\n *       const timer = useEffect(c, ({ interval }) => {\n *         const tid = setInterval(() => { setCount(count() + 1); }, interval);\n *         return () => { clearInterval(tid); };\n *       }, shallowEq);\n *\n *       return (interval) => (\n *         timer({ interval }),\n *\n *         htm`<span>${count()}</span>`\n *       );\n *     });\n *\n * @typeparam T Hook props type.\n * @param component Component instance.\n * @param hook Side effect function.\n * @param areEqual Function that checks if input value hasn't changed.\n * @returns Side effect hook.\n */\nexport const useEffect = (component, hook, areEqual) => {\n    // var usage is intentional, see `docs/internals/perf.md` for an explanation.\n    var reset;\n    var prev;\n    var pending;\n    return (next) => {\n        if (pending !== true && (areEqual === void 0 ||\n            prev === void 0 ||\n            areEqual(prev, next) === false)) {\n            if (pending === void 0) {\n                useUnmount(component, () => {\n                    pending = false;\n                    if (reset !== void 0) {\n                        reset();\n                    }\n                });\n            }\n            pending = true;\n            RENDER_CONTEXT.e.push(() => {\n                if (pending === true) {\n                    pending = false;\n                    if (reset !== void 0) {\n                        reset();\n                    }\n                    reset = hook(next);\n                }\n            });\n        }\n        prev = next;\n    };\n};\nlet _layoutEffects = [];\nlet _idleEffects = [];\nconst _flushLayoutEffects = () => {\n    while (_layoutEffects.length > 0) {\n        const e = _layoutEffects;\n        _layoutEffects = [];\n        for (let i = 0; i < e.length; i++) {\n            e[i]();\n        }\n    }\n};\nconst _flushIdleEffects = () => {\n    while (_idleEffects.length > 0) {\n        const e = _idleEffects;\n        _idleEffects = [];\n        for (let i = 0; i < e.length; i++) {\n            e[i]();\n        }\n    }\n};\nexport const useLayoutEffect = (component, hook, areEqual) => {\n    // var usage is intentional, see `docs/internals/perf.md` for an explanation.\n    var reset;\n    var prev;\n    var pending;\n    return (next) => {\n        if (pending !== true && (areEqual === void 0 ||\n            prev === void 0 ||\n            areEqual(prev, next) === false)) {\n            if (pending === void 0) {\n                useUnmount(component, () => {\n                    pending = false;\n                    if (reset !== void 0) {\n                        reset();\n                    }\n                });\n            }\n            pending = true;\n            const queue = _layoutEffects;\n            if (queue.length === 0) {\n                _requestAnimationFrame(_flushLayoutEffects);\n            }\n            queue.push(() => {\n                if (pending === true) {\n                    pending = false;\n                    if (reset !== void 0) {\n                        reset();\n                    }\n                    reset = hook(next);\n                }\n            });\n        }\n        prev = next;\n    };\n};\nexport const useIdleEffect = (component, hook, areEqual) => {\n    // var usage is intentional, see `docs/internals/perf.md` for an explanation.\n    var reset;\n    var prev;\n    var pending;\n    return (next) => {\n        if (pending !== true && (areEqual === void 0 ||\n            prev === void 0 ||\n            areEqual(prev, next) === false)) {\n            if (pending === void 0) {\n                useUnmount(component, () => {\n                    pending = false;\n                    if (reset !== void 0) {\n                        reset();\n                    }\n                });\n            }\n            pending = true;\n            const queue = _idleEffects;\n            if (queue.length === 0) {\n                _requestIdleCallback(_flushIdleEffects);\n            }\n            queue.push(() => {\n                if (pending === true) {\n                    pending = false;\n                    if (reset !== void 0) {\n                        reset();\n                    }\n                    reset = hook(next);\n                }\n            });\n        }\n        prev = next;\n    };\n};\n/**\n * Invalidates a component.\n *\n * @param c Component instance.\n */\nexport const invalidate = (c) => {\n    if (!(c.f & 128 /* Flags.Dirty */)) {\n        c.f |= 128 /* Flags.Dirty */;\n        let prev = c;\n        let parent = c.p;\n        while (parent !== null) {\n            // Polymorphic call-sites\n            if (parent.f & 256 /* Flags.DirtySubtree */) {\n                return;\n            }\n            prev = parent;\n            parent.f |= 256 /* Flags.DirtySubtree */;\n            parent = parent.p;\n        }\n        prev.v.d.p1(prev, prev.s1);\n    }\n};\n/**\n * VDescriptor for List nodes.\n */\nexport const LIST_DESCRIPTOR = {\n    f: 4 /* Flags.List */,\n    p1: null,\n    p2: null,\n};\n/**\n * Creates a dynamic list.\n *\n * @typeparam E Entry type.\n * @typeparam K Key type.\n * @param entries Entries.\n * @param getKey Get key from entry function.\n * @param render Render entry function.\n * @returns Dynamic list.\n */\nexport const List = (entries, getKey, render) => ({\n    d: LIST_DESCRIPTOR,\n    p: {\n        k: entries.map(getKey),\n        v: entries.map(render),\n    },\n});\n/**\n * Performs dirty checking in a root subtree.\n *\n * When `forceUpdate` option is enabled, all components in a root subtree will\n * be updated.\n *\n * @param root Root Node.\n * @param forceUpdate Force update components.\n */\nexport const dirtyCheck = (root, forceUpdate) => {\n    _dirtyCheckRoot(root, forceUpdate === true\n        ? 512 /* Flags.ForceUpdate */\n        : 0);\n};\n/**\n * Performs a Dirty Checking in a root subtree.\n *\n * @param root Stateful Root Node.\n * @param updateFlags Update flags (ForceUpdate and DisplaceNode).\n */\nconst _dirtyCheckRoot = (root, updateFlags) => {\n    while ((updateFlags | root.f) & (256 /* Flags.DirtySubtree */ | 512 /* Flags.ForceUpdate */)) {\n        const ctx = RENDER_CONTEXT;\n        const { p, n } = ctx;\n        root.f = 32 /* Flags.Root */;\n        if (root.c !== null) {\n            const domSlot = root.v.p;\n            RENDER_CONTEXT.p = domSlot.p;\n            RENDER_CONTEXT.n = domSlot.n;\n            _dirtyCheck(root.c, updateFlags);\n            updateFlags = 0;\n            _flushDOMEffects();\n        }\n        ctx.p = p;\n        ctx.n = n;\n    }\n};\n/**\n * Updates a root subtree.\n *\n * @param root Stateful Root Node.\n * @param next New Stateless Node.\n * @param updateFlags Update flags (ForceUpdate and DisplaceNode).\n */\nconst _updateRoot = (root, next, updateFlags) => {\n    const ctx = RENDER_CONTEXT;\n    const { p, n } = ctx;\n    const domSlot = root.v.p;\n    ctx.p = domSlot.p;\n    ctx.n = domSlot.n;\n    root.f = 32 /* Flags.Root */;\n    root.c = _update(root, root.c, next, updateFlags);\n    _flushDOMEffects();\n    ctx.p = p;\n    ctx.n = n;\n    _dirtyCheckRoot(root, 0);\n};\n/**\n * Unmounts a root subtree.\n *\n * When `detach` option is enabled, root DOM nodes will be detached from the\n * DOM.\n *\n * @param root Root Node.\n * @param detach Detach root DOM nodes from the DOM.\n */\nexport const unmount = (root, detach) => {\n    if (root.c !== null) {\n        const ctx = RENDER_CONTEXT;\n        const { p, n } = ctx;\n        ctx.p = root.v.p.p;\n        root.f = 32 /* Flags.Root */;\n        _unmount(root.c, detach);\n        ctx.p = p;\n        ctx.n = n;\n    }\n};\n/**\n * Hydrates a root subtree.\n *\n * @param root Root Node.\n * @param v Stateless View Node.\n */\nexport const hydrate = (root, v) => {\n    const domSlot = root.v.p;\n    RENDER_CONTEXT.p = domSlot.p;\n    RENDER_CONTEXT.n = domSlot.n;\n    root.c = _hydrate(root, v);\n    _flushDOMEffects();\n    _dirtyCheckRoot(root, 0);\n};\n/**\n * Hydrates Node.\n *\n * @param parentSNode Parent Stateful Node.\n * @param v Stateless Node.\n * @returns Hydrated Stateful Node.\n */\nconst _hydrate = (parentSNode, v) => {\n    if (v !== false && v != null) {\n        if (typeof v === \"object\") {\n            if (_isArray(v)) {\n                return _hydrateList(parentSNode, 8 /* Flags.Array */, v, v);\n            }\n            else {\n                const descriptor = v.d;\n                const props = v.p;\n                const type = descriptor.f & 127 /* Flags.TypeMask */;\n                if (type === 1 /* Flags.Template */) {\n                    const ctx = RENDER_CONTEXT;\n                    const tplData = descriptor.p1;\n                    const stateOpCodes = tplData.s;\n                    const propOpCodes = tplData.p;\n                    const data = tplData.d;\n                    const flags = tplData.f;\n                    const state = _Array(flags & 63 /* TemplateFlags.Mask6 */);\n                    const currentDOMNode = ctx.n === null\n                        ? nodeGetLastChild.call(ctx.p)\n                        : nodeGetPreviousSibling.call(ctx.n);\n                    state[0] = currentDOMNode;\n                    if (stateOpCodes.length > 0) {\n                        ctx.si = 0;\n                        _hydrateAssignTemplateSlots(currentDOMNode, nodeGetFirstChild.call(currentDOMNode), stateOpCodes, 0, stateOpCodes.length, state);\n                    }\n                    if (propOpCodes.length > 0) {\n                        let currentElement = currentDOMNode;\n                        for (let i = 0; i < propOpCodes.length; i++) {\n                            const op = propOpCodes[i];\n                            const type = op & 7 /* PropOpCode.TypeMask */;\n                            const dataIndex = op >> 9 /* PropOpCode.DataShift */;\n                            // TODO: optimize (skip attributes)\n                            if (type === 0 /* PropOpCode.SetNode */) {\n                                currentElement = state[dataIndex];\n                            }\n                            else {\n                                const prop = props[(op >> 3 /* PropOpCode.InputShift */) & 63 /* PropOpCode.Mask6 */];\n                                if (type === 7 /* PropOpCode.Directive */) {\n                                    prop(currentElement, true);\n                                }\n                                else {\n                                    const key = data[dataIndex];\n                                    if (type === 6 /* PropOpCode.Event */) {\n                                        if (prop != null && prop !== false) {\n                                            elementAddEventListener.call(currentElement, key, prop);\n                                        }\n                                    }\n                                    else { // type === PropOpCode.Property || type === PropOpCode.DiffDOMProperty\n                                        if (currentElement[key] !== prop) {\n                                            currentElement[key] = prop;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    const parentElement = ctx.p;\n                    const stateNode = createSNode(1 /* Flags.Template */, v, null, parentSNode, state);\n                    const childrenSize = (flags >> 6 /* TemplateFlags.ChildrenSizeShift */) & 63 /* TemplateFlags.Mask6 */;\n                    if (childrenSize > 0) {\n                        const childOpCodes = tplData.c;\n                        const children = _Array(childrenSize);\n                        stateNode.c = children;\n                        ctx.p = currentDOMNode;\n                        ctx.n = null;\n                        let childrenIndex = 0;\n                        for (let i = 0; i < childOpCodes.length; i++) {\n                            const childOpCode = childOpCodes[i];\n                            const type = childOpCode & 3 /* ChildOpCode.Type */;\n                            const value = childOpCode >> 2 /* ChildOpCode.ValueShift */;\n                            if (type === 0 /* ChildOpCode.Child */) {\n                                children[childrenIndex++] = _hydrate(stateNode, props[value]);\n                            }\n                            else if (type === 1 /* ChildOpCode.SetNext */) {\n                                ctx.n = state[value];\n                            }\n                            else { // ChildOpCode.SetParent\n                                ctx.p = state[value];\n                                ctx.n = null;\n                            }\n                        }\n                        ctx.p = parentElement;\n                    }\n                    ctx.n = currentDOMNode;\n                    return stateNode;\n                }\n                else if (type === 2 /* Flags.Component */) {\n                    const sNode = {\n                        f: 2 /* Flags.Component */,\n                        v: v,\n                        c: null,\n                        p: parentSNode,\n                        s1: null,\n                        s2: null,\n                    };\n                    const renderFn = descriptor.p1(sNode);\n                    sNode.c = _hydrate(sNode, renderFn(props));\n                    sNode.s1 = renderFn;\n                    return sNode;\n                }\n                else if (type === 4 /* Flags.List */) {\n                    return _hydrateList(parentSNode, 4 /* Flags.List */, props.v, v);\n                }\n                // Context\n                const sNode = createSNode(64 /* Flags.Context */, v, null, parentSNode, null);\n                sNode.c = _hydrate(sNode, props.c);\n                return sNode;\n            }\n        }\n        else if (v !== \"\") { // Text\n            const ctx = RENDER_CONTEXT;\n            let node = ctx.n === null\n                ? nodeGetLastChild.call(ctx.p)\n                : nodeGetPreviousSibling.call(ctx.n);\n            // Edge case: [dynamic text, dynamic text]\n            while (nodeGetNodeType.call(node) === 8 /* NodeType.Comment */) {\n                const comment = node;\n                node = nodeGetPreviousSibling.call(node);\n                comment.remove();\n            }\n            ctx.n = node;\n            return createSNode(16 /* Flags.Text */, v, null, parentSNode, node);\n        }\n    }\n    return null;\n};\nconst _hydrateList = (parentState, flags, children, vNode) => {\n    let i = children.length;\n    const sChildren = _Array(i);\n    const sNode = createSNode(flags, vNode, sChildren, parentState, null);\n    while (i > 0) {\n        sChildren[--i] = _hydrate(sNode, children[i]);\n    }\n    return sNode;\n};\nconst _parseInt = parseInt;\nconst _parseOffset = (s, _i) => _parseInt(s, 16);\nconst _hydrateAssignTemplateSlots = (parentElement, currentNode, opCodes, offset, endOffset, state) => {\n    const ctx = RENDER_CONTEXT;\n    let exprOffsetIndex = 0;\n    let exprOffsets;\n    // text edge cases:\n    //\n    //   [text, { element }, text]\n    //                      ^ prevExpr flag\n    //\n    //   [text, <!>, { text }, <!>, { text }, <!>, text]\n    //                                       ^ prevExpr flag\n    //         [            ] [            ] [         ]\n    //\n    while (true) {\n        const op = opCodes[offset++];\n        if (op & 4 /* StateOpCode.PrevExpr */) {\n            // Lazy getAttribute call.\n            if (exprOffsets === void 0) {\n                exprOffsets = elementGetAttribute.call(parentElement, \"&\")\n                    .split(\" \")\n                    .map(_parseOffset);\n            }\n            let exprOffset = exprOffsets[exprOffsetIndex++];\n            while (exprOffset-- > 0) {\n                if (nodeGetNodeType.call(currentNode) === 8 /* NodeType.Comment */) {\n                    const comment = currentNode;\n                    currentNode = nodeGetNextSibling.call(currentNode);\n                    comment.remove();\n                }\n                currentNode = nodeGetNextSibling.call(currentNode);\n            }\n        }\n        if (op & 1 /* StateOpCode.Save */) {\n            state[++ctx.si] = currentNode;\n        }\n        if (op & 2 /* StateOpCode.EnterOrRemove */) {\n            const enterOffset = op >> 3 /* StateOpCode.OffsetShift */;\n            // Enter offset is used to disambiguate between enter and remove\n            // operations. Remove operations will always have a 0 enterOffset.\n            if (enterOffset) { // Enter\n                let node = nodeGetFirstChild.call(currentNode);\n                _hydrateAssignTemplateSlots(currentNode, node, opCodes, offset, offset += enterOffset, state);\n            }\n            else { // Remove\n                // Remove operation implies that current node can be a comment node\n                // followed by a text node.\n                if (nodeGetNodeType.call(currentNode) === 8 /* NodeType.Comment */) {\n                    const comment = currentNode;\n                    currentNode = nodeGetNextSibling.call(currentNode);\n                    comment.remove();\n                }\n                state[++ctx.si] = currentNode;\n            }\n        }\n        if (offset === endOffset) {\n            return;\n        }\n        currentNode = nodeGetNextSibling.call(currentNode);\n    }\n};\n/**\n * Defines a root node with a custom invalidation hook.\n *\n * @param onInvalidate Invalidated Hook.\n * @returns Root Node factory.\n */\nexport const defineRoot = (p1) => {\n    var d = { f: 32 /* Flags.Root */, p1, p2: null };\n    return (p, n = null, s) => createSNode(32 /* Flags.Root */, \n    // VNode object.\n    {\n        // Root Descriptor.\n        d,\n        // VNode props object contains the location in the DOM tree where subtree\n        // should be rendered.\n        p: {\n            // Parent DOM Element.\n            p,\n            // Next DOM Node.\n            n,\n        },\n    }, \n    // Children.\n    null, \n    // Parent SNode.\n    null, \n    // Root state.\n    s);\n};\n/**\n * Creates a root node that uses microtask queue for scheduling updates.\n *\n * @param parentElement Parent DOM Element.\n * @param nextNode Next DOM Node.\n * @returns Root Node.\n */\nexport const createRoot = /*@__PURE__*/ defineRoot(\n// OnRootInvalidated hook\n(root) => {\n    // Schedules a microtask for dirty checking.\n    _queueMicrotask(() => {\n        _dirtyCheckRoot(root, 0);\n    });\n});\n/**\n * Updates a root subtree.\n *\n * When `forceUpdate` option is enabled, all components in a root subtree will\n * be updated.\n *\n * @param root Root Node.\n * @param v Stateless View Node.\n * @param forceUpdate Force update components.\n */\nexport const update = (root, v, forceUpdate) => {\n    _updateRoot(root, v, forceUpdate === true\n        ? 512 /* Flags.ForceUpdate */\n        : 0);\n};\nexport const context = () => {\n    const d = { f: 64 /* Flags.Context */, p1: null, p2: null };\n    return [\n        (c) => _getContextValue(c, d),\n        (v, c) => ({ d, p: { v, c } }),\n    ];\n};\nconst _getContextValue = (c, d) => {\n    let node = c.p;\n    while (node !== null) {\n        if (node.f & 64 /* Flags.Context */ && node.v.d === d) {\n            return node.v.p.v;\n        }\n        node = node.p;\n    }\n};\n//# sourceMappingURL=core.js.map","/**\n* Copyright (c) 2023, Leon Sorokin\n* All rights reserved. (MIT Licensed)\n*\n* uDSV.js\n* A small, fast CSV parser\n* https://github.com/leeoniya/uDSV (v0.5.3)\n*/\n\nconst comma = ',';\nconst quote = '\"';\nconst tab   = '\\t';\nconst pipe  = '|';\nconst semi  = ';';\n\nconst ISO8601 = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d{3,})?(?:Z|[-+]\\d{2}:?\\d{2})$/;\nconst BOOL_RE = /^(?:t(?:rue)?|f(?:alse)?|y(?:es)?|n(?:o)?|0|1)$/i;\n\nconst COL_DELIMS = [tab, pipe, semi, comma];\nconst CHUNK_SIZE = 1e3;\n\nfunction boolTrue(v) {\n\tlet [c0, c1 = ''] = v;\n\n\treturn (\n\t\tc0 == '1' || c0 == '0' ? '1' :\n\n\t\tc0 == 't' || c0 == 'f' ? (c1 == '' ? 't' : 'true') :\n\t\tc0 == 'T' || c0 == 'F' ? (c1 == '' ? 'T' : c1 == 'R' || c1 === 'A' ? 'TRUE' : 'True') :\n\n\t\tc0 == 'y' || c0 == 'n' ? (c1 == '' ? 'y' : 'yes') :\n\t\tc0 == 'Y' || c0 == 'N' ? (c1 == '' ? 'Y' : c1 == 'E' || c1 === 'O' ? 'YES'  : 'Yes')  :\n\n\t\t''\n\t);\n}\n\n// inversion function, from b:<type> string (above)\nfunction boolFalse(v) {\n\tlet [c0, c1 = ''] = v;\n\n\treturn (\n\t\tc0 == '1' ? '0' :\n\n\t\tc0 == 't' ? (c1 == '' ? 'f' : 'false') :\n\t\tc0 == 'T' ? (c1 == '' ? 'F' : c1 == 'R' ? 'FALSE' : 'False') :\n\n\t\tc0 == 'y' ? (c1 == '' ? 'n' : 'no') :\n\t\tc0 == 'Y' ? (c1 == '' ? 'N' : c1 == 'E' ? 'NO'  : 'No')  :\n\n\t\t''\n\t);\n}\n\nfunction isJSON(v) {\n\tif (v[0] === '[' || v[0] === '{') {\n\t\ttry {\n\t\t\tJSON.parse(v);\n\t\t\treturn true;\n\t\t} catch {}\n\t}\n\n\treturn false;\n}\n\nconst T_STRING  = 's';\nconst T_DATE    = 'd';\nconst T_NUMBER  = 'n';\nconst T_JSON    = 'j';\nconst T_BOOLEAN = 'b';\n\nfunction guessType(ci, rows) {\n\t// row with a value to analyze\n\tlet row = rows.findLast(r =>\n\t\tr[ci] !== ''     &&\n\t\tr[ci] !== 'null' &&\n\t\tr[ci] !== 'NULL' &&\n\t\tr[ci] !== 'NaN'\n\t);\n\n\tlet t = T_STRING;\n\n\tif (row != null) {\n\t\tlet v = row[ci];\n\n\t\tt = (\n\t\t\tISO8601.test(v) ? T_DATE                        :\n\t\t\t+v === +v       ? T_NUMBER                      :\n\t\t\tBOOL_RE.test(v) ? T_BOOLEAN + ':' + boolTrue(v) :\n\t\t\tisJSON(v)       ? T_JSON                        :\n\t\t\tt\n\t\t);\n\t}\n\n\treturn t;\n}\n\nconst toJSON = JSON.stringify;\nconst escRegex = str => str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\nconst onlyStrEsc = v => typeof v === 'string' ? toJSON(v) : v;\n\nfunction getValParseExpr(ci, col) {\n\tlet { type } = col;\n\n\tlet rv = `r[${ci}]`;\n\n\tlet parseExpr =\n\t\ttype    === T_DATE    ? `new Date(${rv})`                                   :\n\t\ttype    === T_JSON    ? `JSON.parse(${rv})`                                 :\n\t\ttype    === T_NUMBER  ? `+${rv}`                                            :\n\t\ttype[0] === T_BOOLEAN ? `${rv} === ${toJSON(type.slice(2))} ? true : false` :\n\t\trv;\n\n\tlet { repl } = col;\n\n\tlet nanExpr   = repl.NaN   !== void 0 && type === T_NUMBER ? `${rv} === 'NaN' ? ${onlyStrEsc(repl.NaN)} : `                       : '';\n\tlet nullExpr  = repl.null  !== void 0                      ? `${rv} === 'null' || ${rv} === 'NULL' ? ${onlyStrEsc(repl.null)} : ` : '';\n\tlet emptyExpr = repl.empty !== void 0                      ? `${rv} === '' ? ${onlyStrEsc(repl.empty)} : `                        : '';\n\n\treturn `${emptyExpr} ${nullExpr} ${nanExpr} ${parseExpr}`;\n}\n\nconst segsRe = /\\w+(?:\\[|\\]?[\\.\\[]?|$)/gm;\n\nfunction genToTypedRows(cols, objs = false, deep = false) {\n\tlet buf = '';\n\n\tif (objs && deep) {\n\t\tlet tplObj = {};\n\t\tlet colIdx = 0;\n\n\t\tlet paths = cols.map(c => c.name.replace(/\\.(\\d+)\\.?/gi, '[$1]'));\n\n\t\tdo {\n\t\t\tlet path = paths.shift();\n\n\t\t\tlet segs = /\\s/.test(path) ? [path] : [...path.matchAll(segsRe)].flatMap(m => m.map(m => m.replace(']', '')));\n\n\t\t\tlet node = tplObj;\n\t\t\tdo {\n\t\t\t\tlet seg = segs.shift();\n\n\t\t\t\tlet key = seg;\n\t\t\t\tlet endChar = seg.at(-1);\n\t\t\t\tlet hasKids = endChar == '.' || endChar == '[';\n\n\t\t\t\tif (hasKids) {\n\t\t\t\t\tkey = seg.slice(0, -1);\n\t\t\t\t\tlet nextNode = node[key] ?? (endChar == '.' ? {} : []);\n\t\t\t\t\tnode = node[key] = nextNode;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tnode[key] = `${colIdx}`;\n\t\t\t} while (segs.length > 0);\n\n\t\t\tcolIdx++;\n\t\t} while (paths.length > 0);\n\n\t\tbuf = toJSON(tplObj).replace(/\"(\\d+)\"/g, (m, ci) => getValParseExpr(+ci, cols[+ci]));\n\t}\n\telse {\n\t\tif (!objs && cols.every(c => c.type === T_STRING))\n\t\t\tbuf = 'r';\n\t\telse {\n\t\t\tbuf = objs ? '{' : '[';\n\n\t\t\tcols.forEach((col, ci) => {\n\t\t\t\tbuf += objs ? `${toJSON(col.name)}:` : '';\n\t\t\t\tlet parseVal = getValParseExpr(ci, col);\n\t\t\t\tbuf += `${parseVal},`;\n\t\t\t});\n\n\t\t\tbuf += objs ? '}' : ']';\n\t\t}\n\t}\n\n\tlet fnBody = `\n\t\tlet arr = Array(rows.length);\n\n\t\tfor (let i = 0; i < rows.length; i++) {\n\t\t\tlet r = rows[i];\n\t\t\tarr[i] = ${buf};\n\t\t}\n\n\t\treturn arr;\n\t`;\n\n\tlet toObjFn = new Function('rows', fnBody);\n\n\t// console.log(fnBody);\n\t// console.log(toObjFn(chunk.slice(1, 5)));\n\t// process.exit();\n\n\treturn toObjFn;\n}\n\nfunction genToCols(cols) {\n\treturn new Function('rows', `\n\t\tlet cols = [${cols.map(() => `Array(rows.length)`).join(',')}];\n\n\t\tfor (let i = 0; i < rows.length; i++) {\n\t\t\tlet r = rows[i];\n\t\t\t${cols.map((c, i) => `cols[${i}][i] = r[${i}]`).join(';')};\n\t\t}\n\n\t\treturn cols;\n\t`);\n}\n\n// https://www.loc.gov/preservation/digital/formats/fdd/fdd000323.shtml\nfunction inferSchema(csvStr, opts, maxRows) {\n\tlet {\n\t\theader: headerFn,\n\t\tcol:    colDelim,\n\t\trow:    rowDelim,\n\t\tencl:   colEncl,\n\t\tesc:    escEncl,\n\t//\tomit,  // #comments and empty lines (ignore:), needs callback for empty and comments?\n\t\ttrim  = false,\n\t} = opts ?? {};\n\n\t// by default, grab first row, and skip it\n\theaderFn ??= firstRows => [firstRows[0]];\n\n\tmaxRows ??= 10;\n\n\t// will fail if header contains line breaks in quoted value\n\t// will fail if single line without line breaks\n\tconst rowRE         = new RegExp(`(.*)(${rowDelim ?? '\\r\\n|\\r|\\n'})`);\n\tconst firstRowMatch = csvStr.match(rowRE);\n\tconst firstRowStr   = firstRowMatch[1];\n\n\trowDelim ??= firstRowMatch[2];\n\tcolDelim ??= COL_DELIMS.find(delim => firstRowStr.indexOf(delim) > -1) ?? '';\n\n\tconst schema = {\n\t\tskip: 1, // how many header rows to skip\n\t\tcol:  colDelim,\n\t\trow:  rowDelim,\n\t\tencl: colEncl,\n\t\tesc:  escEncl,\n\t\ttrim: trim,\n\t\tcols: [],\n\t};\n\n\tconst _maxCols = firstRowStr.split(colDelim).length;\n\n\tconst firstRows = [];\n\tparse(csvStr, schema, chunk => { firstRows.push(...chunk); }, 0, true, maxRows, 1, _maxCols);\n\n\tlet headerRows = headerFn(firstRows) ?? [];\n\n\tlet skip = schema.skip = headerRows.length;\n\n\t// first non-null row\n\tlet colNames = headerRows.find(row => row != null) ?? [...Array(firstRows[0].length).keys()];\n\n\tfirstRows.splice(0, skip);\n\n\tcolNames.forEach((colName, colIdx) => {\n\t\tlet type = guessType(colIdx, firstRows);\n\n\t\tlet col = {\n\t\t\tname: colName,\n\t\t\ttype,\n\t\t\t// this could be type-dependant (e.g. {empty: 0, null: 0, NaN: NaN} for numbers)\n\t\t\trepl: {\n\t\t\t\tempty: null,\n\t\t\t\tNaN: void 0,\n\t\t\t\tnull: void 0,\n\t\t\t},\n\t\t};\n\n\t\tschema.cols.push(col);\n\t});\n\n\treturn schema;\n}\n\n// no stream out support\n// no support for whitespace-padded cols (anti-trim)\n// TODO: allow forcing no enclosures\nfunction genFromRows(schema, objs = false, deep = false) {\n\tlet { skip, col, row, encl, esc, cols } = schema;\n\n\tlet enclTpl = toJSON(encl);\n\tlet escTpl = toJSON(esc + encl);\n\tlet strTpl = v => `${enclTpl} + ${v}.replaceAll(${enclTpl}, ${escTpl}) + ${enclTpl}`;\n\n\tlet bodyTpl = cols.map(({name, type, encl}, ci) => {\n\t\t// TODO: also allow header renaming\n\t\tlet val = `r[${objs ? toJSON(name) : ci}]`;\n\t\tlet out = val;\n\n\t\tif (type[0] == T_BOOLEAN) {\n\t\t\tlet t = type.slice(2);\n\t\t\tlet f = boolFalse(t);\n\t\t\tout = t == `${val} ? '${t}' : '${f}'`;\n\t\t}\n\t\telse if (type == T_STRING)\n\t\t\tout = encl ? strTpl(val) : encl == false ? val : `(!strChk.test(${val}) ? ${val} : ${strTpl(val)})`;\n\t\telse if (type == T_DATE)\n\t\t\tout = `${val}.toISOString()`;\n\t\telse if (type == T_JSON)\n\t\t\tout = strTpl(`JSON.stringify(${val})`);\n\n\t\t// nulls will always emit as empty strings\n\t\treturn `(${val} == null ? '' : ${out})`;\n\t}).join(' + ' + toJSON(col) + ' + ') + ' + ' + toJSON(row);\n\n\t// TODO: support skip for headerless?\n\tlet reStr = `${escRegex(col)}|${escRegex(row)}|${escRegex(encl)}`;\n\tlet re = new RegExp(reStr);\n\t// TODO: also allow header renaming\n\tlet headStr = cols.map(c => !re.test(c.name) ? c.name : encl + c.name.replaceAll(encl, esc + encl) + encl).join(col) + row;\n\n\treturn new Function(`\n\t\tlet strChk = new RegExp(${toJSON(reStr)});\n\n\t\treturn rows => {\n\t\t\tlet out = ${toJSON(headStr)};\n\n\t\t\tfor (let i = 0; i < rows.length; i++) {\n\t\t\t\tlet r = rows[i];\n\t\t\t\tout += ${bodyTpl};\n\t\t\t}\n\n\t\t\treturn out;\n\t\t}\n\t`)();\n}\nfunction initUnparser(schema) {\n\tlet _fromArrs = null;\n\tlet _fromObjs = null;\n\n\treturn {\n\t\tschema,\n\n\t\tfromArrs(data) {\n\t\t\t_fromArrs ??= genFromRows(schema);\n\t\t\treturn _fromArrs(data);\n\t\t},\n\t\tfromObjs(data) {\n\t\t\t_fromObjs ??= genFromRows(schema, true);\n\t\t\treturn _fromObjs(data);\n\t\t},\n\t\t// TODO\n\t\tfromDeep(data) {},\n\t\tfromCols(data) {},\n\t};\n}\n\nfunction initParser(schema, chunkSize) {\n\tlet { skip, cols } = schema;\n\n\tlet _toStrs = null;\n\tlet _toArrs = null;\n\tlet _toObjs = null;\n\tlet _toDeep = null;\n\n\tlet _toCols = null;\n\n\tlet streamChunkNum = 0;\n\tlet streamState = 0;\n\tlet streamParse = null;\n\tlet streamCb = null;\n\tlet pendChunk = '';\n\tlet prevUnparsed = '';\n\n\tlet buf = null;\n\n\tfunction reset() {\n\t\tstreamState = streamChunkNum = 0;\n\t\tprevUnparsed = pendChunk = '';\n\t\tstreamParse = streamCb = buf = null;\n\t}\n\n\tlet accum    = (rows, add) => { add(rows); };\n\tlet initRows = () => [];\n\tlet initCols = () => cols.map(c => []);\n\tlet addRows  = rows => { buf.push(...rows); };\n\tlet addCols  = cols => { cols.forEach((vals, ci) => { buf[ci].push(...vals); }); };\n\n\tfunction gen(accInit, accAppend, genConvertRows) {\n\t\tlet convertRows = null;\n\n\t\treturn (csvStr, cb = accum) => {\n\t\t\tconvertRows ??= genConvertRows();\n\n\t\t\tbuf ??= accInit();\n\t\t\tlet out = buf;\n\t\t\tlet withEOF = streamState === 0 || streamState === 2;\n\n\t\t\tlet _skip = streamChunkNum === 0 ? skip : 0;\n\n\t\t\tparse(csvStr, schema, (rows, partial) => {\n\t\t\t\tprevUnparsed = partial;\n\t\t\t\tlet res = cb(convertRows(rows), accAppend);\n\n\t\t\t\tif (res === false && streamState !== 0)\n\t\t\t\t\treset();\n\n\t\t\t\treturn res;\n\t\t\t}, _skip, withEOF, chunkSize);\n\n\t\t\tif (withEOF)\n\t\t\t\tbuf = null;\n\n\t\t\treturn out;\n\t\t};\n\t}\n\n\tconst stringArrs = gen(initRows, addRows, () => {\n\t\t_toStrs ??= rows => rows;\n\t\treturn _toStrs;\n\t});\n\n\tconst typedArrs = gen(initRows, addRows, () => {\n\t\t_toArrs ??= genToTypedRows(cols, false, false);\n\t\treturn _toArrs;\n\t});\n\n\tconst typedObjs = gen(initRows, addRows, () => {\n\t\t_toObjs ??= genToTypedRows(cols, true, false);\n\t\treturn _toObjs;\n\t});\n\n\tconst typedDeep = gen(initRows, addRows, () => {\n\t\t_toDeep ??= genToTypedRows(cols, true, true);\n\t\treturn _toDeep;\n\t});\n\n\tconst typedCols = gen(initCols, addCols, () => {\n\t\t_toArrs ??= genToTypedRows(cols, false, false);\n\t\t_toCols ??= genToCols(cols);\n\n\t\treturn rows => _toCols(_toArrs(rows));\n\t});\n\n\treturn {\n\t\tschema,\n\n\t\tstringArrs,\n\t\ttypedArrs,\n\t\ttypedObjs,\n\t\ttypedDeep,\n\t\ttypedCols,\n\n\t\tchunk(csvStr, parse = stringArrs, cb = accum) {\n\t\t\tstreamParse ??= parse;\n\t\t\tstreamCb    ??= cb;\n\n\t\t\tif (streamState === 1) {\n\t\t\t\tstreamParse(prevUnparsed + pendChunk, streamCb);\n\t\t\t\tstreamChunkNum++;\n\t\t\t}\n\n\t\t\tpendChunk = csvStr;\n\t\t\tstreamState = 1;\n\t\t},\n\t\tend() {\n\t\t\tstreamState = 2;\n\t\t\tlet out = streamParse(prevUnparsed + pendChunk, streamCb);\n\t\t\treset();\n\t\t\treturn out;\n\t\t},\n\t};\n}\n\nfunction parse(csvStr, schema, cb, skip = 0, withEOF = true, chunkSize = CHUNK_SIZE, chunkLimit = null, _maxCols = null) {\n\tlet {\n\t\trow:  rowDelim,\n\t\tcol:  colDelim,\n\t\tencl: colEncl,\n\t\tesc:  escEncl,\n\t\ttrim,\n\t} = schema;\n\n\tcolEncl  ??= csvStr.indexOf(quote) > -1 ? quote : ''; \t// TODO: detect single quotes?\n\tescEncl  ??= colEncl;\n\n\tlet numCols = _maxCols || schema.cols.length;\n\n\tlet _limit = chunkLimit != null;\n\t// uses a slower regexp path for schema probing\n\tlet _probe = _maxCols != null && _limit;\n\n\tlet rowDelimLen = rowDelim.length;\n\tlet colDelimLen = colDelim.length;\n\n\tlet colEnclChar  = colEncl.charCodeAt(0);\n\tlet escEnclChar  = escEncl.charCodeAt(0);\n\tlet rowDelimChar = rowDelim.charCodeAt(0);\n\tlet colDelimChar = colDelim.charCodeAt(0);\n\tlet spaceChar    = 32;\n\n\tlet numChunks = 0;\n\n\tlet pos = 0;\n\tlet endPos = csvStr.length - 1;\n\tlet linePos = 0;\n\n\tlet rows = [];\n\tlet rowTpl = Array(numCols).fill('');\n\tlet row = rowTpl.slice();\n\n\tlet colIdx = 0;\n\tlet lastColIdx = numCols - 1;\n\tlet filledColIdx = -1;\n\n\tif (colEncl === '') {\n\t\twhile (pos <= endPos) {\n\t\t\tif (colIdx === lastColIdx) {\n\t\t\t\tlet pos2 = csvStr.indexOf(rowDelim, pos);\n\n\t\t\t\tif (pos2 === -1) {\n\t\t\t\t\tif (!withEOF)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tpos2 = endPos + 1;\n\t\t\t\t}\n\n\t\t\t\tlet s = csvStr.slice(pos, pos2);\n\t\t\t\trow[colIdx] = trim ? s.trim() : s;\n\n\t\t\t\t--skip < 0 && rows.push(row);\n\n\t\t\t\tif (rows.length === chunkSize) {\n\t\t\t\t\tlet stop = cb(rows, '') === false;\n\t\t\t\t\trows = [];\n\n\t\t\t\t\tif (stop || _limit && ++numChunks === chunkLimit)\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\trow = rowTpl.slice();\n\t\t\t\tcolIdx = 0;\n\t\t\t\tfilledColIdx = -1;\n\t\t\t\tpos = pos2 + rowDelimLen;\n\t\t\t\tlinePos = pos;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// empty line\n\t\t\t\tif (colIdx === 0 && csvStr.charCodeAt(pos) === rowDelimChar) {\n\t\t\t\t\tpos += rowDelimLen;\n\t\t\t\t\t// TODO: callback here!\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlet pos2 = csvStr.indexOf(colDelim, pos);\n\n\t\t\t\t\tif (pos2 === -1) {\n\t\t\t\t\t\tif (!withEOF)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet s = csvStr.slice(pos, pos2);\n\t\t\t\t\trow[colIdx] = trim ? s.trim() : s;\n\t\t\t\t\tpos = pos2 + colDelimLen;\n\t\t\t\t\tfilledColIdx = colIdx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (withEOF && colIdx === lastColIdx)\n\t\t\t--skip < 0 && rows.push(row);\n\n\t\tif (!withEOF || rows.length > 0)\n\t\t\tcb(rows, !withEOF ? csvStr.slice(linePos) : '');\n\n\t\treturn;\n\t}\n\n\t// should this be * to handle ,, ?\n\tconst takeToCommaOrEOL = _probe ? new RegExp(`[^${colDelim}${rowDelim}]+`, 'my') : null;\n\n\t// 0 = no\n\t// 1 = unquoted\n\t// 2 = quoted\n\tlet inCol = 0;\n\n\tlet v = \"\";\n\tlet c;\n\n\twhile (pos <= endPos) {\n\t\tc = csvStr.charCodeAt(pos);\n\n\t\tif (inCol === 0) {\n\t\t\tif (c === colEnclChar) {\n\t\t\t\tinCol = 2;\n\t\t\t\tpos += 1;\n\n\t\t\t\tif (pos > endPos)\n\t\t\t\t\tbreak;\n\n\t\t\t\tc = csvStr.charCodeAt(pos);\n\t\t\t}\n\t\t\telse if (c === colDelimChar || c === rowDelimChar) {\n\t\t\t\t// PUSH MACRO START\n\t\t\t\tif (c === rowDelimChar && colIdx === 0) {\n\t\t\t\t\tpos += rowDelimLen;\n\t\t\t\t\t// TODO: callback here!\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\trow[colIdx] = v;\n\t\t\t\tfilledColIdx = colIdx;\n\t\t\t\tcolIdx += 1;\n\n\t\t\t\tpos += 1;\n\t\t\t\tv = \"\";\n\n\t\t\t\tif (c === rowDelimChar) {\n\t\t\t\t\tif (_probe && filledColIdx < lastColIdx && rows.length === 0) {\n\t\t\t\t\t\trow.length = rowTpl.length = filledColIdx + 1;\n\t\t\t\t\t\tlastColIdx = filledColIdx;\n\t\t\t\t\t}\n\n\t\t\t\t\t--skip < 0 && rows.push(row);\n\n\t\t\t\t\tif (rows.length === chunkSize) {\n\t\t\t\t\t\tlet stop = cb(rows, '') === false;\n\t\t\t\t\t\trows = [];\n\n\t\t\t\t\t\tif (stop || _limit && ++numChunks === chunkLimit)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\trow = rowTpl.slice();\n\t\t\t\t\tcolIdx = 0;\n\t\t\t\t\tfilledColIdx = -1;\n\t\t\t\t\tpos += rowDelimLen - 1;\n\t\t\t\t\tlinePos = pos;\n\t\t\t\t}\n\t\t\t\t// PUSH MACRO END\n\n\t\t\t\tif (pos > endPos)\n\t\t\t\t\tbreak;\n\n\t\t\t\tc = csvStr.charCodeAt(pos);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (trim && c === spaceChar) {\n\t\t\t\t\twhile (c === spaceChar)\n\t\t\t\t\t\tc = csvStr.charCodeAt(++pos);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tinCol = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (inCol === 2) {\n\t\t\twhile (true) {\n\t\t\t\tif (c === colEnclChar) {\n\t\t\t\t\tif (colEnclChar === escEnclChar) {\n\t\t\t\t\t\tif (pos + 1 > endPos) { // TODO: test with chunk ending in closing \", even at EOL but not EOF\n\t\t\t\t\t\t\tpos = endPos + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet cNext = csvStr.charCodeAt(pos + 1);\n\n\t\t\t\t\t\tif (cNext === colEnclChar) {\n\t\t\t\t\t\t\tpos += 2;\n\n\t\t\t\t\t\t\t// MACRO START\n\t\t\t\t\t\t\tv += colEncl;\n\t\t\t\t\t\t\tif (pos > endPos)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tc = csvStr.charCodeAt(pos);\n\t\t\t\t\t\t\t// MACRO END\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tinCol = 0;\n\t\t\t\t\t\t\tpos += 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet cPrev = csvStr.charCodeAt(pos - 1);\n\n\t\t\t\t\t\tif (cPrev === escEnclChar) {\n\t\t\t\t\t\t\tpos += 1;\n\n\t\t\t\t\t\t\t// MACRO START\n\t\t\t\t\t\t\tv += colEncl;\n\t\t\t\t\t\t\tif (pos > endPos)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tc = csvStr.charCodeAt(pos);\n\t\t\t\t\t\t\t// MACRO END\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tinCol = 0;\n\t\t\t\t\t\t\tpos += 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlet pos2 = csvStr.indexOf(colEncl, pos);\n\n\t\t\t\t\tif (pos2 === -1) {\n\t\t\t\t\t\tpos = endPos + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tv += csvStr.slice(pos, colEnclChar === escEnclChar ? pos2 : pos2 - 1);\n\t\t\t\t\tpos = pos2;\n\t\t\t\t\tc = colEnclChar;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (inCol === 1) {\n\t\t\tif (c === colDelimChar || c === rowDelimChar) {\n\t\t\t\t// PUSH MACRO START\n\t\t\t\tif (c === rowDelimChar && colIdx === 0) {\n\t\t\t\t\tpos += rowDelimLen;\n\t\t\t\t\t// TODO: callback here!\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\trow[colIdx] = v;\n\t\t\t\tfilledColIdx = colIdx;\n\t\t\t\tcolIdx += 1;\n\n\t\t\t\tpos += 1;\n\t\t\t\tv = \"\";\n\n\t\t\t\tif (c === rowDelimChar) {\n\t\t\t\t\tif (_probe && filledColIdx < lastColIdx && rows.length === 0) {\n\t\t\t\t\t\trow.length = rowTpl.length = filledColIdx + 1;\n\t\t\t\t\t\tlastColIdx = filledColIdx;\n\t\t\t\t\t}\n\n\t\t\t\t\t--skip < 0 && rows.push(row);\n\n\t\t\t\t\tif (rows.length === chunkSize) {\n\t\t\t\t\t\tlet stop = cb(rows, '') === false;\n\t\t\t\t\t\trows = [];\n\n\t\t\t\t\t\tif (stop || _limit && ++numChunks === chunkLimit)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\trow = rowTpl.slice();\n\t\t\t\t\tcolIdx = 0;\n\t\t\t\t\tfilledColIdx = -1;\n\t\t\t\t\tpos += rowDelimLen - 1;\n\t\t\t\t\tlinePos = pos;\n\t\t\t\t}\n\t\t\t\t// PUSH MACRO END\n\n\t\t\t\tinCol = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (_probe) {\n\t\t\t\t\ttakeToCommaOrEOL.lastIndex = pos;\n\t\t\t\t\tlet m = takeToCommaOrEOL.exec(csvStr)[0];\n\t\t\t\t\tv += m;\n\t\t\t\t\tpos += m.length;  // rowdelim when - 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlet pos2 = csvStr.indexOf(colIdx === lastColIdx ? rowDelim : colDelim, pos);\n\n\t\t\t\t\tif (pos2 === -1)\n\t\t\t\t\t\tpos2 = endPos + 1;\n\n\t\t\t\t\tlet s = csvStr.slice(pos, pos2);\n\t\t\t\t\tv += trim ? s.trim() : s;\n\t\t\t\t\tpos = pos2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (withEOF && colIdx === lastColIdx) {\n\t\trow[colIdx] = v;\n\t\t--skip < 0 && rows.push(row);\n\t\tinCol = 0;\n\t}\n\n\tlet partial = !withEOF && (\n\t\tinCol !== 0 ||\n\t\t(\n\t\t\tfilledColIdx === -1 ? v !== '' :  // partial first col OR\n\t\t\tfilledColIdx < lastColIdx         // not all cols filled\n\t\t)\n\t);\n\n\tcb(rows, partial ? csvStr.slice(linePos) : '');\n}\n\n// const parsed = {\n// \tformat: '',\n// \tdata: []\n// };\n\nexport { inferSchema, initParser, initUnparser };\n","const cleanRHS = v => JSON.stringify(v);\nconst cleanLHS = (path, chain = false) => {\n  if (path == null || path == '' || path == '$' || path == '$i')\n    return path;\n\n  let cleanPath = '';\n\n  // guard against access outside of scope\n  if (path[0] == '.' || path[0] == '[') {\n    // remove baddies\n    cleanPath = path.replace(/[^$\\w.?\\[\\]-]/ig, '');\n\n    // add optional chaining\n    if (chain) {\n      cleanPath = cleanPath\n        .replace(/\\.\\??/ig, '.?')\n        .replace(/(?:\\.\\?)?\\[/ig, '.?[');\n    }\n  }\n\n  return '$' + cleanPath;\n}\n\nconst EMPTY_ARR = [];\nconst EMPTY_OBJ = {};\n\nlet OPTS = { chain: false, ops: EMPTY_OBJ };\n\nexport function compileExpr(node, opts = OPTS, stmts = []) {\n  let op = node[0];\n  let lhs = node[1];\n  let rhs = node[2];\n\n  let expr = '';\n\n  let negate = op[0] == '!' && op != '!=' && op != '!==' && op != '!!' && op != '!';\n\n  op = negate ? op.slice(1) : op;\n\n  let $ops = opts.ops ?? EMPTY_OBJ;\n\n  if (typeof $ops[op] == 'function' && /^\\w+$/.test(op)) {\n    stmts.push(`let $args = ${JSON.stringify(lhs ?? null)};`);\n    expr = `$ops.${op}($, $i, $args)`;\n  }\n  else {\n    let path = op != '&&' && op != '||' ? cleanLHS(lhs, opts.chain) : '';\n\n    switch (op) {\n      case '&&':\n      case '||':\n        let exprs = node.slice(1).map(node2 => compileExpr(node2, opts, stmts));\n        expr = exprs.length > 1 ? `(${exprs.map(o => o.expr).join(` ${op} `)})` : exprs[0].expr;\n        break;\n\n      case 'truthy':\n      case '!!':\n        expr = `Boolean(${path})`;\n        break;\n      case 'falsy':\n      case '!':\n        expr = `!Boolean(${path})`;\n        break;\n\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n      case '>=':\n      case '<=':\n      case '<':\n      case '>':\n        expr = `${path} ${op} ${cleanRHS(rhs)}`;\n        break;\n\n      case 'some':\n      case 'every':\n        expr = `${path}.${op}(($, $i) => ${compileExpr(rhs, opts, stmts).expr})`;\n        break;\n\n      case ',':\n      case 'in':\n        expr = `$${stmts.length}.has(${path})`;\n        stmts.push(`let $${stmts.length} = new Set(${cleanRHS(rhs)});`);\n        break;\n\n      case '-':\n      case '[]':\n      case '()':\n      case '[)':\n      case '(]':\n        if (!Array.isArray(rhs)) break;\n\n        let [min, max] = rhs;\n        let [l, r] = op;\n        let lop = l == '[' || l == '-' ? '>=' : '>';\n        let rop = r == ']' || r == null ? '<=' : '<';\n        expr = `${path} ${lop} ${cleanRHS(min)} && ${path} ${rop} ${cleanRHS(max)}`;\n        break;\n\n      case 'startsWith':\n      case '^':\n        expr = `${path}.startsWith(${cleanRHS(rhs)})`;\n        break;\n\n      case 'endsWith':\n      case '$':\n        expr = `${path}.endsWith(${cleanRHS(rhs)})`;\n        break;\n\n      case 'includes':\n      case '*':\n        expr = `${path}.includes(${cleanRHS(rhs)})`;\n        break;\n\n      case 'regexp':\n      case 'regexpi':\n      case '/':\n      case '/i':\n        let flags = op.at(-1) == 'i' ? 'i' : '';\n        expr = `$${stmts.length}.test(${path})`;\n        stmts.push(`let $${stmts.length} = new RegExp(${cleanRHS(rhs)}, \"${flags}\");`);\n        break;\n\n      case 'isInteger':\n      case 'isFinite':\n      case 'isNaN':\n        expr = `Number.${op}(${path})`;\n        break;\n\n      case 'isArray':\n        expr = `Array.isArray(${path})`;\n        break;\n    }\n  }\n\n  expr = negate ? `!(${expr})` : expr;\n\n  return {\n    stmts,\n    expr\n  };\n}\n\nexport function compileMatcher(nodes, opts = OPTS) {\n  let { expr, stmts } = compileExpr(nodes, opts);\n\n  return new Function('$ops', `\n    ${stmts.join('\\n')};\n    return ($, $i = 0) => ${expr};\n  `)(opts.ops ?? EMPTY_OBJ);\n}\n\n/*\n// these are for loop exits\ncase 'all'\ncase 'first': // early break after count\ncase 'last':  // backwards early break\n  lhs = node[1]; // howMany\n  rhs = node[2];\ncase 'only':  // early return nothing if count > 1\n*/\n\nfunction _compileFilter(nodes, opts = OPTS, useIdx = false) {\n  let { expr, stmts } = compileExpr(nodes, opts);\n\n  return new Function('$ops', `\n    ${stmts.join('\\n')}\n    return arr => {\n      let out = [];\n      for (let $i = 0; $i < arr.length; $i++) {\n        let $ = arr[$i];\n        ${expr} && out.push(${useIdx ? '$i' : '$'});\n      }\n      return out;\n    };\n  `)(opts.ops ?? EMPTY_OBJ);\n}\n\n// objs struct should be like {\"prop\": [1,2,3,4], \"other\": ['a','b','c']}\nexport function compileExprCols(nodes, names = EMPTY_ARR, opts = OPTS) {\n  let { expr, stmts } = compileExpr(nodes, opts);\n\n  if (names.length > 0) {\n    names.forEach((name, i) => {\n      if (!/[^\\w.]/.test(name)) {\n        expr = expr.replaceAll(name, `[${i}][$i]`);\n      }\n    });\n  }\n\n  return { expr, stmts };\n}\n\nexport function compileMatcherCols(nodes, names, opts = OPTS) {\n  let { expr, stmts } = compileExprCols(nodes, names, opts);\n\n  return new Function('$ops', `\n    ${stmts.join('\\n')};\n    return ($, $i = 0) => ${expr};\n  `)(opts.ops ?? EMPTY_OBJ);\n}\n\nconst filterColsIdxsBody = expr => `\n      let len = cols[0].length;\n\n      let $ = cols;\n      let idxs = [];\n\n      for (let $i = 0; $i < len; $i++) {\n        ${expr} && idxs.push($i);\n      }\n`;\n\nexport function compileFilterColsIdxs(nodes, names, opts = OPTS) {\n  let { expr, stmts } = compileExprCols(nodes, names, opts);\n\n  return new Function('$ops', `\n    ${stmts.join('\\n')}\n    return cols => {\n      ${filterColsIdxsBody(expr)}\n      return idxs;\n    };\n  `)(opts.ops ?? EMPTY_OBJ);\n}\n\nexport function compileFilterCols(nodes, names, opts = OPTS) {\n  let { expr, stmts } = compileExprCols(nodes, names, opts);\n\n  return new Function('$ops', `\n    ${stmts.join('\\n')}\n    return cols => {\n      ${filterColsIdxsBody(expr)}\n\n      return cols.map(col => {\n        let fcol = [];\n\n        for (let i = 0; i < idxs.length; i++) {\n          fcol.push(col[idxs[i]]);\n        }\n\n        return fcol;\n      });\n    };\n  `)(opts.ops ?? EMPTY_OBJ);\n}\n\nexport const compileFilter = (nodes, opts = OPTS) => _compileFilter(nodes, opts);\nexport const compileFilterIdxs = (nodes, opts = OPTS) => _compileFilter(nodes, opts, true);\n\n// TODO:\n// insert optional chaining\n// support negative index to avoid handling .at(-1) fn call\n// hasKey?\n// typeof (string, boolean, number, function, object, array)\n// date ranges?\n// array intersect? (list in list)",null,"import { invalidate } from \"./core.js\";\n/**\n * Creates a memoized function.\n *\n * @example\n *\n *     const Example = component((c) => {\n *       const fullName = useMemo(shallowEqArray, ([firstName, lastName]) => (\n *         `${firstName} ${lastName}`\n *       ));\n *\n *       return ({firstName, lastName}) => htm`\n *         div.fullName ${fullName([firstName, lastName])}\n *       `;\n *     });\n *\n * @typeparam T Input type.\n * @typeparam U Output type.\n * @param areEqual Function that checks if input value hasn't changed.\n * @param fn Function to memoize.\n * @returns Memoized function.\n */\nexport const useMemo = (areEqual, fn) => {\n    var prev;\n    var v;\n    return (props) => ((v === void 0 || areEqual(prev, props) === false)\n        ? v = fn(prev = props)\n        : v);\n};\n/**\n * Creates a reactive state.\n *\n * @example\n *\n *     const Example = component((c) => {\n *       const [getCounter, setCounter] = useState(c, 0);\n *       const inc = () => { setCounter(getCounter() + 1); };\n *\n *       return () => htm`\n *         div.app\n *           div.counter ${getCounter()}\n *           button @click=${inc} 'Increment'\n *       `;\n *     });\n *\n * @typeparam S State type.\n * @param component Component instance.\n * @param state Initial state value.\n * @returns A tuple with a getter and setter functions.\n */\nexport const useState = (component, state) => ([\n    // getter\n    () => state,\n    // setter\n    (next) => {\n        if (next !== state) {\n            state = next;\n            invalidate(component);\n        }\n    }\n]);\n/**\n * Creates a reactive state reducer.\n *\n * @example\n *\n *     function reducer(state, action) {\n *       switch (action.type) {\n *         case \"inc\":\n *           return state + 1;\n *       }\n *       return state;\n *     }\n *\n *     const Example = component((c) => {\n *        const [counter, dispatch] = useReducer(c, 0, reducer);\n *        const inc = () => { dispatch(\"inc\"); };\n *\n *       return () => htm`\n *         div.app\n *           div.counter ${counter()}\n *           button @click=${inc} 'Increment'\n *       `;\n *     });\n *\n * @typeparam S State type.\n * @typeparam A Reducer action type.\n * @param component Component instance.\n * @param state Initial state.\n * @param reducer Reducer function.\n * @returns State getter and dispatch functions.\n */\nexport const useReducer = (component, state, reducer) => ([\n    () => state,\n    (action) => {\n        const nextState = reducer(state, action);\n        if (state !== nextState) {\n            state = nextState;\n            invalidate(component);\n        }\n        return state;\n    }\n]);\n//# sourceMappingURL=state.js.map"],"names":["EMPTY_ARRAY","__IVI_DATA__","_Object","Object","_Array","Array","_isArray","isArray","_Map","Map","_Int32Array","Int32Array","_queueMicrotask","queueMicrotask","nodeProto","Node","prototype","elementProto","Element","doc","document","HTM_TEMPLATE","createElement","HTM_TEMPLATE_CONTENT","content","firstChild","nodeInsertBefore","insertBefore","nodeRemoveChild","removeChild","nodeCloneNode","cloneNode","elementSetAttribute","setAttribute","elementRemoveAttribute","removeAttribute","elementAddEventListener","addEventListener","elementRemoveEventListener","removeEventListener","getDescriptor","o","p","getOwnPropertyDescriptor","nodeGetFirstChild","get","nodeGetNextSibling","nodeSetTextContent","set","elementSetInnerHTML","elementSetClassName","htmlElementGetStyle","HTMLElement","svgElementGetStyle","SVGElement","RENDER_CONTEXT","seal","n","si","e","createSNode","f","v","c","s1","_flushDOMEffects","length","i","_updateTemplateProperties","currentElement","opCodes","data","state","prevProps","nextProps","svg","style","op","type","dataIndex","propsIndex","next","key","prev","call","nodeValue","setProperty","removeProperty","_assignTemplateSlots","currentNode","offset","endOffset","ctx","enterOffset","commentNode","remove","_mountList","parentState","flags","children","vNode","sChildren","sNode","_mount","_update","parentSNode","updateFlags","_unmount","_dirtyCheck","_updateArray","prevSChildren","nextSChildren","prevLength","nextLength","sChild","descriptor","d","p2","parentElement","tplData","p1","propsOpCodes","childOpCodes","rootDOMNode","childrenIndex","childOpCode","value","_updateList","props","descriptorP1","parentDOMElement","nextDOMNode","stateOpCodes","s","s2","renderFn","createTextNode","detach","unmountHooks","a","b","aKeys","k","bKeys","bVNodes","bLength","aLength","result","aEnd","bEnd","start","outer","sources","keyIndex","j","nodePosition","nextPosition","markLIS","node","lisValue","parent","index","lo","hi","indexLength","_h","t","innerHTML","_hE","_T","_t","component","getProps","invalidate","_dirtyCheckRoot","root","domSlot","createRoot","defineRoot","quote","ISO8601","BOOL_RE","COL_DELIMS","CHUNK_SIZE","T_STRING","T_DATE","T_NUMBER","T_JSON","T_BOOLEAN","guessType","ci","rows","row","findLast","r","test","c0","c1","boolTrue","JSON","parse","isJSON","toJSON","stringify","onlyStrEsc","getValParseExpr","col","rv","parseExpr","slice","repl","nanExpr","NaN","nullExpr","null","empty","segsRe","genToTypedRows","cols","objs","deep","buf","tplObj","colIdx","paths","map","name","replace","path","shift","segs","matchAll","flatMap","m","seg","endChar","at","nextNode","every","forEach","parseVal","Function","inferSchema","csvStr","opts","maxRows","header","headerFn","colDelim","rowDelim","encl","colEncl","esc","escEncl","trim","firstRows","rowRE","RegExp","firstRowMatch","match","firstRowStr","find","delim","indexOf","schema","skip","_maxCols","split","chunk","push","headerRows","colNames","keys","splice","colName","initParser","chunkSize","_toStrs","_toArrs","_toObjs","_toDeep","_toCols","streamChunkNum","streamState","streamParse","streamCb","pendChunk","prevUnparsed","reset","accum","add","initRows","addRows","gen","accInit","accAppend","genConvertRows","convertRows","cb","out","withEOF","partial","res","stringArrs","typedArrs","typedObjs","typedDeep","typedCols","initCols","vals","join","genToCols","end","chunkLimit","numCols","_limit","_probe","rowDelimLen","colDelimLen","colEnclChar","charCodeAt","escEnclChar","rowDelimChar","colDelimChar","numChunks","pos","endPos","linePos","rowTpl","fill","lastColIdx","filledColIdx","pos2","stop","takeToCommaOrEOL","inCol","lastIndex","exec","cleanRHS","cleanLHS","chain","cleanPath","EMPTY_OBJ","OPTS","ops","compileExpr","stmts","lhs","rhs","expr","negate","exprs","node2","min","max","l","rop","_compileFilter","nodes","useIdx","cmp","Intl","Collator","numeric","sensitivity","compare","_tpl_","_EMPTY_ARRAY","CSVDropper","onDrop","preventDefault","item","dataTransfer","items","kind","file","getAsFile","endsWith","text","then","setData","onDragOver","_tpl_2","_tpl_3","_tpl_4","_tpl_5","_tpl_6","_tpl_7","Table","dom","setDom","el","sortFn","filtFn","table","filts","sortDir","sortPos","dataFilt","reFilt","rules","nonEmpty","filter","compileFilter","compileMatcherStringTuples","reSort","compileSorterStringTuples","dir","simple","sorts","sort","body","scrollTop","rowHgt","viewRows","chunkLen","Math","idx0","colWids","setIdx0","force","idx1","incrRoundDn","num","incr","floor","useEffect","hook","areEqual","pending","useUnmount","hooks","resizeObserver","ResizeObserver","sync","rFull","getBoundingClientRect","rThead","querySelector","viewHgt","height","rTbody","colEl","querySelectorAll","width","observe","unobserve","disconnect","onClicks","idx","onClickCol","onChangeFiltOps","onChangeFiltOp","target","onChangeFiltVals","onChangeFiltVal","val","totalHgt","padTop","padBtm","App","getData","useState","update","forceUpdate","_updateRoot"],"mappings":"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","x_google_ignoreList":[0,1,2,4]}