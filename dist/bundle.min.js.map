{"version":3,"file":"bundle.min.js","sources":["../node_modules/ivi/dist/lib/core.js","../node_modules/ivi/dist/lib/state.js","../node_modules/udsv/dist/uDSV.mjs","../node_modules/uexpr/src/uExpr.mjs","../src/main.ts"],"sourcesContent":["export const EMPTY_ARRAY = [];\n/**\n * Globally shared strings is automatically generated by optimizer.\n */\nconst __IVI_STRINGS__ = /*@__IVI_STRINGS__*/ [];\n// Store global variables in a local scope as const variables so that JIT\n// compiler could easily inline functions and eliminate checks in case global\n// variables are overriden.\nconst _Object = Object;\nconst _Array = Array;\nconst _isArray = _Array.isArray;\nconst _Map = Map;\nconst _Int32Array = Int32Array;\nconst _queueMicrotask = queueMicrotask;\nconst _requestAnimationFrame = requestAnimationFrame;\nconst _requestIdleCallback = requestIdleCallback;\nconst nodeProto = Node.prototype;\nconst elementProto = Element.prototype;\nconst doc = document;\n// Template containers are used to create static templates from HTML strings\n// via `innerHTML`.\nconst HTM_TEMPLATE = /**@__PURE__*/ doc.createElement(\"template\");\nconst HTM_TEMPLATE_CONTENT = HTM_TEMPLATE.content;\nconst _SVG_TEMPLATE = /**@__PURE__*/ doc.createElement(\"template\");\nconst SVG_TEMPLATE = /**@__PURE__*/ doc.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n/**@__PURE__*/ _SVG_TEMPLATE.content.appendChild(SVG_TEMPLATE);\nconst SVG_TEMPLATE_CONTENT = _SVG_TEMPLATE.content.firstChild;\n// Store Node/Element methods to avoid going through a long prototype chain and\n// avoid megamorphic call-sites when accessing DOM nodes.\n/** `Node.prototype.insertBefore` */\nconst nodeInsertBefore = nodeProto.insertBefore;\n/** `Node.prototype.removeChild`. */\nconst nodeRemoveChild = nodeProto.removeChild;\n/** `Node.prototype.cloneNode`. */\nconst nodeCloneNode = nodeProto.cloneNode;\n/** `Element.prototype.setAttribute` */\nconst elementSetAttribute = elementProto.setAttribute;\n/** `Element.prototype.removeAttribute` */\nconst elementRemoveAttribute = elementProto.removeAttribute;\n/** `EventTarget.prototype.addEventListener` */\nconst elementAddEventListener = elementProto.addEventListener;\n/** `EventTarget.prototype.removeEventListener` */\nconst elementRemoveEventListener = elementProto.removeEventListener;\n/** `Object.getOwnPropertyDescriptor(o, p)` */\nconst getDescriptor = (o, p) => _Object.getOwnPropertyDescriptor(o, p);\n/** `get Node.prototype.firstChild` */\nconst nodeGetFirstChild = /*@__PURE__*/ getDescriptor(nodeProto, \"firstChild\").get;\n/** `get Node.prototype.nextSibling` */\nconst nodeGetNextSibling = /*@__PURE__*/ getDescriptor(nodeProto, \"nextSibling\").get;\n/** `set Node.prototype.textContent` */\nconst nodeSetTextContent = /*@__PURE__*/ getDescriptor(nodeProto, \"textContent\").set;\n/** `set Element.prototype.innerHTML` */\nconst elementSetInnerHTML = /*@__PURE__*/ getDescriptor(elementProto, \"innerHTML\").set;\n/** `set Element.prototype.className` */\nconst elementSetClassName = /*@__PURE__*/ getDescriptor(elementProto, \"className\").set;\n/** `get HTMLElement.prototype.style`. */\nconst htmlElementGetStyle = /*@__PURE__*/ getDescriptor(HTMLElement.prototype, \"style\").get;\n/** `get SVGElement.prototype.style` */\nconst svgElementGetStyle = /*@__PURE__*/ getDescriptor(SVGElement.prototype, \"style\").get;\n// When object is sealed and stored in a const variable, JIT compiler can\n// eliminate object map(shape) checks when accessing its properties.\n/**\n * Global Render Context.\n */\nexport const RENDER_CONTEXT = _Object.seal({\n    p: null,\n    n: null,\n    si: 0,\n    e: [],\n});\n/**\n * Creates a Stateful Node instance.\n *\n * @param v VNode.\n * @returns {@link SNode} instance.\n */\nexport const createSNode = (f, v, c, p, s1) => ({ f, v, c, p, s1 });\nexport const _flushDOMEffects = () => {\n    const e = RENDER_CONTEXT.e;\n    if (e.length > 0) {\n        RENDER_CONTEXT.e = [];\n        for (let i = 0; i < e.length; i++) {\n            e[i]();\n        }\n    }\n};\nconst _updateTemplateProperties = (currentElement, opCodes, data, state, prevProps, nextProps, svg) => {\n    let style;\n    for (let i = 0; i < opCodes.length; i++) {\n        const op = opCodes[i];\n        const type = op & 7 /* PropOpCode.TypeMask */;\n        const dataIndex = op >> 9 /* PropOpCode.DataShift */;\n        if (type === 0 /* PropOpCode.SetNode */) {\n            currentElement = state[dataIndex];\n            style = void 0;\n        }\n        else {\n            const propsIndex = (op >> 3 /* PropOpCode.InputShift */) & 63 /* PropOpCode.Mask6 */;\n            const next = nextProps[propsIndex];\n            if (type === 4 /* PropOpCode.DiffDOMProperty */) {\n                const key = data[dataIndex];\n                if (prevProps === null) {\n                    if (next !== void 0) {\n                        currentElement[key] = next;\n                    }\n                }\n                else if (currentElement[key] !== next) {\n                    currentElement[key] = next;\n                }\n            }\n            else {\n                let prev;\n                if (prevProps !== null) {\n                    prev = prevProps[propsIndex];\n                }\n                if (prev !== next) {\n                    if (type === 1 /* PropOpCode.Common */) {\n                        if (dataIndex === 0 /* CommonPropType.ClassName */) {\n                            if (next !== \"\" && next != null && next !== false) {\n                                elementSetClassName.call(currentElement, next);\n                            }\n                            else if (prev !== \"\" && prev != null && prev !== false) {\n                                elementSetClassName.call(currentElement, \"\");\n                            }\n                        }\n                        else if (dataIndex === 1 /* CommonPropType.TextContent */) {\n                            if (next !== \"\" && next != null && next !== false) {\n                                if (prev == null || prev === \"\" || prev === false) {\n                                    nodeSetTextContent.call(currentElement, next);\n                                }\n                                else {\n                                    nodeGetFirstChild.call(currentElement).nodeValue = next;\n                                }\n                            }\n                            else if (prev != null && prev !== \"\" && prev !== false) {\n                                nodeSetTextContent.call(currentElement, \"\");\n                            }\n                        }\n                        else { // CommonPropType.InnerHTML\n                            if (next !== \"\" && next != null && next !== false) {\n                                elementSetInnerHTML.call(currentElement, next);\n                            }\n                            else if (prev !== \"\" && prev != null && prev !== false) {\n                                nodeSetTextContent.call(currentElement, \"\");\n                            }\n                        }\n                    }\n                    else if (type === 7 /* PropOpCode.Directive */) {\n                        next(currentElement);\n                    }\n                    else {\n                        const key = data[dataIndex];\n                        if (type === 2 /* PropOpCode.Attribute */) {\n                            if (next !== false && next != null) {\n                                elementSetAttribute.call(currentElement, key, next);\n                            }\n                            else if (prev !== false && prev != null) {\n                                elementRemoveAttribute.call(currentElement, key);\n                            }\n                        }\n                        else if (type === 3 /* PropOpCode.Property */) {\n                            currentElement[key] = next;\n                        }\n                        else if (type === 5 /* PropOpCode.Style */) {\n                            if (next !== false && next != null) {\n                                if (style === void 0) {\n                                    style = (svg === false)\n                                        ? htmlElementGetStyle.call(currentElement)\n                                        : svgElementGetStyle.call(currentElement);\n                                }\n                                style.setProperty(key, next);\n                            }\n                            else if (prev !== false && prev != null) {\n                                if (style === void 0) {\n                                    style = (svg === false)\n                                        ? htmlElementGetStyle.call(currentElement)\n                                        : svgElementGetStyle.call(currentElement);\n                                }\n                                style.removeProperty(key);\n                            }\n                        }\n                        else { // PropOpCode.Event\n                            if (prev != null && prev !== false) {\n                                elementRemoveEventListener.call(currentElement, key, prev);\n                            }\n                            if (next != null && next !== false) {\n                                elementAddEventListener.call(currentElement, key, next);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n};\nconst _assignTemplateSlots = (currentNode, opCodes, offset, endOffset, state) => {\n    const ctx = RENDER_CONTEXT;\n    while (true) {\n        const op = opCodes[offset++];\n        if (op & 1 /* StateOpCode.Save */) {\n            state[++ctx.si] = currentNode;\n        }\n        if (op & 2 /* StateOpCode.EnterOrRemove */) {\n            const enterOffset = op >> 2 /* StateOpCode.OffsetShift */;\n            // Enter offset is used to disambiguate between enter and remove\n            // operations. Remove operations will always have a 0 enterOffset.\n            if (enterOffset) { // Enter\n                _assignTemplateSlots(nodeGetFirstChild.call(currentNode), opCodes, offset, offset += enterOffset, state);\n            }\n            else { // Remove\n                // Remove operation implies that current node is always a comment node\n                // followed by a text node.\n                const commentNode = currentNode;\n                state[++ctx.si] = currentNode = nodeGetNextSibling.call(currentNode);\n                commentNode.remove();\n            }\n        }\n        if (offset === endOffset) {\n            return;\n        }\n        currentNode = nodeGetNextSibling.call(currentNode);\n    }\n};\nconst _mountList = (parentState, flags, children, vNode) => {\n    let i = children.length;\n    const sChildren = _Array(i);\n    const sNode = createSNode(flags, vNode, sChildren, parentState, null);\n    while (i > 0) {\n        sChildren[--i] = _mount(sNode, children[i]);\n    }\n    return sNode;\n};\nconst _updateArray = (parentSNode, sNode, next, updateFlags) => {\n    if (!_isArray(next)) {\n        _unmount(sNode, true);\n        return _mount(parentSNode, next);\n    }\n    const prevSChildren = sNode.c;\n    let nextSChildren = prevSChildren;\n    let prevLength = prevSChildren.length;\n    let nextLength = next.length;\n    if (nextLength !== prevLength) {\n        sNode.c = nextSChildren = _Array(nextLength);\n        while (prevLength > nextLength) {\n            const sChild = prevSChildren[--prevLength];\n            if (sChild !== null) {\n                _unmount(sChild, true);\n            }\n        }\n        while (nextLength > prevLength) {\n            nextSChildren[--nextLength] = _mount(sNode, next[nextLength]);\n        }\n    }\n    while (nextLength > 0) {\n        nextSChildren[--nextLength] = _update(sNode, prevSChildren[nextLength], next[nextLength], updateFlags);\n    }\n    return sNode;\n};\n/**\n * Updates a Stateful Node with a new Stateless Node.\n *\n * @param parentSNode Parent Stateul Node.\n * @param sNode Stateful Node to update.\n * @param next New Stateless Node.\n * @param updateFlags Update flags (ForceUpdate and DisplaceNode).\n * @returns Stateful Node.\n */\nconst _update = (parentSNode, sNode, next, updateFlags) => {\n    if (sNode === null) {\n        return _mount(parentSNode, next);\n    }\n    if (next === false || next == null || next === \"\") {\n        _unmount(sNode, true);\n        return null;\n    }\n    // polymorphic call-site\n    const children = sNode.c;\n    const prev = sNode.v;\n    const state = sNode.s1;\n    const flags = sNode.f;\n    const type = flags & 127 /* Flags.TypeMask */;\n    sNode.f = type;\n    // Reassign to reduce memory consumption even if next value is strictly\n    // equal to the prev value.\n    sNode.v = next;\n    // Text and Array should be checked before Component, Template and List\n    // because their stateless nodes are represented with basic string and array\n    // types.\n    if (type === 16 /* Flags.Text */) {\n        const ctx = RENDER_CONTEXT;\n        if (typeof next !== \"object\") {\n            if (prev !== next) {\n                state.nodeValue = next;\n            }\n            if (updateFlags & 1024 /* Flags.DisplaceNode */) {\n                nodeInsertBefore.call(ctx.p, state, ctx.n);\n            }\n            ctx.n = state;\n            return sNode;\n        }\n        nodeRemoveChild.call(ctx.p, state);\n        return _mount(parentSNode, next);\n    }\n    if (prev === next) {\n        _dirtyCheck(sNode, updateFlags);\n        return sNode;\n    }\n    // Dirty flags should be cleared after dirty checking.\n    sNode.f = type;\n    if (type === 8 /* Flags.Array */) {\n        return _updateArray(parentSNode, sNode, next, updateFlags);\n    }\n    const descriptor = next.d;\n    const nextProps = next.p;\n    const prevProps = prev.p;\n    if (prev.d !== descriptor) {\n        _unmount(sNode, true);\n        return _mount(parentSNode, next);\n    }\n    if (type === 2 /* Flags.Component */) {\n        if (((flags | updateFlags) & (128 /* Flags.Dirty */ | 512 /* Flags.ForceUpdate */)) ||\n            (descriptor.p2 === void 0) ||\n            (descriptor.p2(prevProps, nextProps) !== true)) {\n            sNode.c = _update(sNode, children, state(nextProps), updateFlags);\n        }\n        else if (children !== null) {\n            _dirtyCheck(children, updateFlags);\n        }\n    }\n    else if (type === 1 /* Flags.Template */) {\n        const ctx = RENDER_CONTEXT;\n        const parentElement = ctx.p;\n        const tplData = descriptor.p1;\n        const flags = tplData.f;\n        const data = tplData.d;\n        const propsOpCodes = tplData.p;\n        const childOpCodes = tplData.c;\n        const rootDOMNode = state[0];\n        if (updateFlags & 1024 /* Flags.DisplaceNode */) {\n            updateFlags ^= 1024 /* Flags.DisplaceNode */;\n            nodeInsertBefore.call(parentElement, rootDOMNode, ctx.n);\n        }\n        _updateTemplateProperties(rootDOMNode, propsOpCodes, data, state, prevProps, nextProps, !!(flags & 4096 /* TemplateFlags.Svg */));\n        if (children !== null) {\n            ctx.p = rootDOMNode;\n            ctx.n = null;\n            let childrenIndex = 0;\n            for (let i = 0; i < childOpCodes.length; i++) {\n                const childOpCode = childOpCodes[i];\n                const type = childOpCode & 3 /* ChildOpCode.Type */;\n                const value = childOpCode >> 2 /* ChildOpCode.ValueShift */;\n                if (type === 0 /* ChildOpCode.Child */) {\n                    children[childrenIndex] =\n                        _update(sNode, children[childrenIndex++], nextProps[value], updateFlags);\n                }\n                else if (type === 1 /* ChildOpCode.SetNext */) {\n                    ctx.n = state[value];\n                }\n                else { // ChildOpCode.SetParent\n                    ctx.p = state[value];\n                    ctx.n = null;\n                }\n            }\n            ctx.p = parentElement;\n        }\n        ctx.n = rootDOMNode;\n    }\n    else if (type === 4 /* Flags.List */) {\n        _updateList(sNode, prevProps, nextProps, updateFlags);\n    }\n    else { // Context\n        if (prevProps.v !== nextProps.v) {\n            updateFlags |= 512 /* Flags.ForceUpdate */;\n        }\n        sNode.c = _update(sNode, children, nextProps.c, updateFlags);\n    }\n    return sNode;\n};\n/**\n * Mounts Stateless Node.\n *\n * @param parentSNode Parent Stateful Node.\n * @param v Stateless Node.\n * @returns Mounted Stateful Node.\n */\nconst _mount = (parentSNode, v) => {\n    if (v !== false && v != null) {\n        if (typeof v === \"object\") {\n            if (_isArray(v)) {\n                return _mountList(parentSNode, 8 /* Flags.Array */, v, v);\n            }\n            else {\n                const descriptor = v.d;\n                const props = v.p;\n                const descriptorP1 = descriptor.p1;\n                const type = descriptor.f & (1 /* Flags.Template */ | 2 /* Flags.Component */ | 4 /* Flags.List */);\n                if (type === 1 /* Flags.Template */) {\n                    const ctx = RENDER_CONTEXT;\n                    const parentDOMElement = ctx.p;\n                    const nextDOMNode = ctx.n;\n                    const tplData = descriptorP1;\n                    const data = tplData.d;\n                    const propsOpCodes = tplData.p;\n                    const stateOpCodes = tplData.s;\n                    const childOpCodes = tplData.c;\n                    const flags = tplData.f;\n                    const rootDOMNode = descriptor.p2();\n                    const state = _Array(flags & 63 /* TemplateFlags.Mask6 */);\n                    state[0] = rootDOMNode;\n                    if (stateOpCodes.length > 0) {\n                        ctx.si = 0;\n                        _assignTemplateSlots(nodeGetFirstChild.call(rootDOMNode), stateOpCodes, 0, stateOpCodes.length, state);\n                    }\n                    _updateTemplateProperties(rootDOMNode, propsOpCodes, data, state, null, props, !!(flags & 4096 /* TemplateFlags.Svg */));\n                    const sNode = createSNode(1 /* Flags.Template */, v, null, parentSNode, state);\n                    if (childOpCodes.length > 0) {\n                        const children = _Array((flags >> 6 /* TemplateFlags.ChildrenSizeShift */) & 63 /* TemplateFlags.Mask6 */);\n                        sNode.c = children;\n                        ctx.p = rootDOMNode;\n                        ctx.n = null;\n                        let childrenIndex = 0;\n                        for (let i = 0; i < childOpCodes.length; i++) {\n                            const childOpCode = childOpCodes[i];\n                            const type = childOpCode & 3 /* ChildOpCode.Type */;\n                            const value = childOpCode >> 2 /* ChildOpCode.ValueShift */;\n                            if (type === 0 /* ChildOpCode.Child */) {\n                                children[childrenIndex++] = _mount(sNode, props[value]);\n                            }\n                            else if (type === 1 /* ChildOpCode.SetNext */) {\n                                ctx.n = state[value];\n                            }\n                            else { // ChildOpCode.SetParent\n                                ctx.p = state[value];\n                                ctx.n = null;\n                            }\n                        }\n                        ctx.p = parentDOMElement;\n                    }\n                    ctx.n = rootDOMNode;\n                    nodeInsertBefore.call(parentDOMElement, rootDOMNode, nextDOMNode);\n                    return sNode;\n                }\n                else if (type === 2 /* Flags.Component */) {\n                    const sNode = {\n                        f: 2 /* Flags.Component */,\n                        v: v,\n                        c: null,\n                        p: parentSNode,\n                        s1: null,\n                        s2: null,\n                    };\n                    const renderFn = descriptorP1(sNode);\n                    sNode.c = _mount(sNode, renderFn(props));\n                    sNode.s1 = renderFn;\n                    return sNode;\n                }\n                else if (type === 4 /* Flags.List */) {\n                    return _mountList(parentSNode, 4 /* Flags.List */, props.v, v);\n                }\n                // Context\n                const sNode = createSNode(64 /* Flags.Context */, v, null, parentSNode, null);\n                sNode.c = _mount(sNode, props.c);\n                return sNode;\n            }\n        }\n        else if (v !== \"\") { // text\n            const ctx = RENDER_CONTEXT;\n            const next = ctx.n;\n            const e = doc.createTextNode(v);\n            ctx.n = e;\n            nodeInsertBefore.call(ctx.p, e, next);\n            return createSNode(16 /* Flags.Text */, v, null, parentSNode, e);\n        }\n    }\n    return null;\n};\n/**\n * Performs a Dirty Checking in a Stateful Node Subtree.\n *\n * @param sNode Stateful Node.\n * @param updateFlags Update flags (ForceUpdate and DisplaceNode).\n */\nconst _dirtyCheck = (sNode, updateFlags) => {\n    const ctx = RENDER_CONTEXT;\n    // polymorphic call-site\n    const state = sNode.s1;\n    const v = sNode.v;\n    const children = sNode.c;\n    const flags = sNode.f;\n    const type = flags & 127 /* Flags.TypeMask */;\n    sNode.f = type;\n    if (type === 1 /* Flags.Template */) {\n        const rootDOMNode = state[0];\n        if (updateFlags & 1024 /* Flags.DisplaceNode */) {\n            updateFlags ^= 1024 /* Flags.DisplaceNode */;\n            nodeInsertBefore.call(ctx.p, rootDOMNode, ctx.n);\n        }\n        if (flags & 256 /* Flags.DirtySubtree */) {\n            ctx.p = rootDOMNode;\n            ctx.n = null;\n            const parentDOMElement = ctx.p;\n            const childOpCodes = v.d.p1.c;\n            let childrenIndex = 0;\n            for (let i = 0; i < childOpCodes.length; i++) {\n                const op = childOpCodes[i];\n                const type = op & 3 /* ChildOpCode.Type */;\n                const value = op >> 2 /* ChildOpCode.ValueShift */;\n                if (type === 0 /* ChildOpCode.Child */) {\n                    const sChild = children[childrenIndex++];\n                    if (sChild !== null) {\n                        _dirtyCheck(sChild, updateFlags);\n                    }\n                }\n                else if (type === 1 /* ChildOpCode.SetNext */) {\n                    ctx.n = state[value];\n                }\n                else { // ChildOpCode.SetParent\n                    ctx.p = state[value];\n                    ctx.n = null;\n                }\n            }\n            ctx.p = parentDOMElement;\n        }\n        ctx.n = rootDOMNode;\n    }\n    else if (type === 16 /* Flags.Text */) {\n        if (updateFlags & 1024 /* Flags.DisplaceNode */) {\n            nodeInsertBefore.call(ctx.p, state, ctx.n);\n        }\n        ctx.n = state;\n    }\n    else if (type === 2 /* Flags.Component */) {\n        if ((flags | updateFlags) & (128 /* Flags.Dirty */ | 512 /* Flags.ForceUpdate */)) {\n            sNode.c = _update(sNode, children, state(v.p), updateFlags);\n        }\n        else if (children !== null) {\n            _dirtyCheck(children, updateFlags);\n        }\n    }\n    else if (type === 64 /* Flags.Context */) {\n        if (children !== null) {\n            _dirtyCheck(children, updateFlags);\n        }\n    }\n    else { // Array || List\n        let i = children.length;\n        while (--i >= 0) {\n            const sChild = children[i];\n            if (sChild !== null) {\n                _dirtyCheck(sChild, updateFlags);\n            }\n        }\n    }\n};\n/**\n * Unmounts Stateful Node.\n *\n * @param sNode Stateful Node.\n * @param detach Detach root DOM nodes from the DOM.\n */\nconst _unmount = (sNode, detach) => {\n    const flags = sNode.f; // polymorphic call-site\n    const sChildren = sNode.c;\n    if (detach === true && (flags & (1 /* Flags.Template */ | 16 /* Flags.Text */))) {\n        detach = false;\n        nodeRemoveChild.call(RENDER_CONTEXT.p, (flags & 1 /* Flags.Template */)\n            ? sNode.s1[0]\n            : sNode.s1);\n    }\n    if (flags & 2 /* Flags.Component */) {\n        const unmountHooks = sNode.s2;\n        if (unmountHooks !== null) {\n            if (typeof unmountHooks === \"function\") {\n                unmountHooks();\n            }\n            else {\n                for (let i = 0; i < unmountHooks.length; i++) {\n                    unmountHooks[i]();\n                }\n            }\n        }\n    }\n    if (sChildren !== null) {\n        if (_isArray(sChildren)) {\n            for (let i = 0; i < sChildren.length; i++) {\n                const sChild = sChildren[i];\n                if (sChild !== null) {\n                    _unmount(sChild, detach);\n                }\n            }\n        }\n        else {\n            _unmount(sChildren, detach);\n        }\n    }\n};\n/**\n * Update children list with track by key algorithm.\n *\n * High-level overview of the algorithm that is implemented in this function:\n *\n * This algorithm finds a minimum number of DOM operations. It works in\n * several steps:\n *\n * 1. Common prefix and suffix optimization.\n *\n * Look for nodes with identical keys by simultaneously iterating through nodes\n * in the old children list `A` and new children list `B` from both sides.\n *\n *     A: -> [a b c d] <-\n *     B: -> [a b d] <-\n *\n * Skip nodes \"a\" and \"b\" at the start, and node \"d\" at the end.\n *\n *     A: -> [c] <-\n *     B: -> [] <-\n *\n * 2. Zero length optimizations.\n *\n * Check if the size of one of the list is equal to zero. When length of the\n * old children list is zero, insert remaining nodes from the new list. When\n * length of the new children list is zero, remove remaining nodes from the old\n * list.\n *\n *     A: -> [a b c g] <-\n *     B: -> [a g] <-\n *\n * Skip nodes \"a\" and \"g\" (prefix and suffix optimization).\n *\n *     A: [b c]\n *     B: []\n *\n * Remove nodes \"b\" and \"c\".\n *\n * 3. Index and unmount removed nodes.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *     P: [. . . . .] // . == -1\n *\n * Create array `P` (`sources`) with the length of the new children list and\n * fills it with `NewNodeMark` values. This mark indicates that node at this\n * position should be mounted. Later we will assign node positions in the old\n * children list to this array.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *     P: [. . . . .] // . == -1\n *     I: {\n *       c: 0, // B[0] == c\n *       b: 1, // B[1] == b\n *       h: 2,\n *       f: 3,\n *       e: 4,\n *     }\n *     last = 0\n *\n * Create reverse index `I` that maps keys to node positions in the new\n * children list.\n *\n *     A: [b c d e f]\n *         ^\n *     B: [c b h f e]\n *     P: [. 0 . . .] // . == -1\n *     I: {\n *       c: 0,\n *       b: 1, <-\n *       h: 2,\n *       f: 3,\n *       e: 4,\n *     }\n *     last = 1\n *\n * Assign original positions of the nodes from the old children list to the\n * array `P`.\n *\n * Iterate through nodes in the old children list and gets their new positions\n * from the index `I`. Assign old node position to the array `P`. When index\n * `I` doesn't have a key for the old node, it means that it should be\n * unmounted.\n *\n * When we assigning positions to the array `P`, we also store position of the\n * last seen node in the new children list `pos`, if the last seen position is\n * greater than the current position of the node at the new list, then we are\n * switching `rearrangeNodes` flag to `true` (`pos === RearrangeNodes`).\n *\n *     A: [b c d e f]\n *           ^\n *     B: [c b h f e]\n *     P: [1 0 . . .] // . == -1\n *     I: {\n *       c: 0, <-\n *       b: 1,\n *       h: 2,\n *       f: 3,\n *       e: 4,\n *     }\n *     last = 1 // last > 0; rearrangeNodes = true\n *\n * The last position `1` is greater than the current position of the node at the\n * new list `0`, switch `rearrangeNodes` flag to `true`.\n *\n *     A: [b c d e f]\n *             ^\n *     B: [c b h f e]\n *     P: [1 0 . . .] // . == -1\n *     I: {\n *       c: 0,\n *       b: 1,\n *       h: 2,\n *       f: 3,\n *       e: 4,\n *     }\n *     rearrangeNodes = true\n *\n * Node with key \"d\" doesn't exist in the index `I`, unmounts node `d`.\n *\n *     A: [b c d e f]\n *               ^\n *     B: [c b h f e]\n *     P: [1 0 . . 3] // . == -1\n *     I: {\n *       c: 0,\n *       b: 1,\n *       h: 2,\n *       f: 3,\n *       e: 4, <-\n *     }\n *     rearrangeNodes = true\n *\n * Assign position `3` for `e` node.\n *\n *     A: [b c d e f]\n *                 ^\n *     B: [c b h f e]\n *     P: [1 0 . 4 3] // . == -1\n *     I: {\n *       c: 0,\n *       b: 1,\n *       h: 2,\n *       f: 3, <-\n *       e: 4,\n *     }\n *     rearrangeNodes = true\n *\n * Assign position `4` for 'f' node.\n *\n * 4. Find minimum number of moves when `rearrangeNodes` flag is on and mount\n *    new nodes.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *     P: [1 * . 4 *] // . == -1  * == -2\n *\n * When `rearrangeNodes` is on, mark all nodes in the array `P` that belong to\n * the [longest increasing subsequence](http://en.wikipedia.org/wiki/Longest_increasing_subsequence)\n * and move all nodes that doesn't belong to this subsequence.\n *\n * Iterate over the new children list and the `P` array simultaneously. When\n * value from `P` array is equal to `NewNodeMark`, mount a new node. When it\n * isn't equal to `LisMark`, move it to a new position.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *                 ^  // new_pos == 4\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *                 ^\n *\n * Node \"e\" has `LisMark` value in the array `P`, nothing changes.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *               ^    // new_pos == 3\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *               ^\n *\n * Node \"f\" has `4` value in the array `P`, move it before the next node \"e\".\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *             ^      // new_pos == 2\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *             ^\n *\n * Node \"h\" has `NewNodeMark` value in the array `P`, mount new node \"h\".\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *           ^        // new_pos == 1\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *           ^\n *\n * Node \"b\" has `LisMark` value in the array `P`, nothing changes.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *         ^          // new_pos == 0\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *\n * Node \"c\" has `1` value in the array `P`, move it before the next node \"b\".\n *\n * When `rearrangeNodes` flag is off, skip LIS algorithm and mount nodes that\n * have `NewNodeMark` value in the array `P`.\n *\n * NOTE: There are many variations of this algorithm that are used by many UI\n * libraries and many implementations are still using an old optimization\n * technique that were removed several years ago from this implementation. This\n * optimization were used to improve performance of simple moves/swaps. E.g.\n *\n *     A: -> [a b c] <-\n *     B: -> [c b a] <-\n *\n * Move \"a\" and \"c\" nodes to the other edge.\n *\n *     A: -> [b] <-\n *     B: -> [b] <-\n *\n * Skip node \"b\".\n *\n * This optimization were removed because it breaks invariant that insert and\n * remove operations shouldn't trigger a move operation. E.g.\n *\n *     A: -> [a b]\n *     B:    [c a] <-\n *\n * Move node \"a\" to the end.\n *\n *     A: [b]\n *     B: [c a]\n *\n * Remove node \"b\" and insert node \"c\".\n *\n * In this use case, this optimization performs one unnecessary operation.\n * Instead of removing node \"b\" and inserting node \"c\", it also moves node \"a\".\n *\n * @param sNode {@link SList} node.\n * @param a Previous {@link ListProps}.\n * @param b Next {@link ListProps}.\n * @param updateFlags Update flags.\n * @noinline\n * @__NOINLINE__\n */\nconst _updateList = (sNode, a, b, updateFlags) => {\n    const aKeys = a.k;\n    const bKeys = b.k;\n    const bVNodes = b.v;\n    let bLength = bKeys.length;\n    let aLength = aKeys.length;\n    const result = _Array(bLength);\n    if (bLength === 0) { // New children list is empty.\n        if (aLength > 0) { // Unmount nodes from the old children list.\n            _unmount(sNode, true);\n        }\n    }\n    else if (aLength === 0) { // Old children list is empty.\n        while (bLength > 0) { // Mount nodes from the new children list.\n            result[--bLength] = _mount(sNode, bVNodes[bLength]);\n        }\n    }\n    else {\n        const sChildren = sNode.c;\n        let aEnd = aLength - 1;\n        let bEnd = bLength - 1;\n        let start = 0;\n        // Step 1\n        outer: while (true) {\n            // Update nodes with the same key at the end.\n            while (aKeys[aEnd] === bKeys[bEnd]) {\n                result[bEnd] = _update(sNode, sChildren[aEnd--], bVNodes[bEnd], updateFlags);\n                if (start > --bEnd || start > aEnd) {\n                    break outer;\n                }\n            }\n            // Update nodes with the same key at the beginning.\n            while (aKeys[start] === bKeys[start] && ++start <= aEnd && start <= bEnd) {\n                // delayed update (all updates should be performed from right-to-left).\n            }\n            break;\n        }\n        // Step 2\n        if (start > aEnd) {\n            // All nodes from `a` are updated, insert the rest from `b`.\n            while (bEnd >= start) {\n                result[bEnd] = _mount(sNode, bVNodes[bEnd--]);\n            }\n        }\n        else if (start > bEnd) {\n            // All nodes from `b` are updated, remove the rest from `a`.\n            bLength = start;\n            do {\n                const sChild = sChildren[bLength++];\n                if (sChild !== null) {\n                    _unmount(sChild, true);\n                }\n            } while (bLength <= aEnd);\n        }\n        else { // Step 3\n            let bLength = bEnd - start + 1;\n            const sources = new _Int32Array(bLength); // Maps positions in the new children list to positions in the old list.\n            const keyIndex = new _Map(); // Maps keys to their positions in the new children list.\n            for (let i = 0; i < bLength; i++) {\n                // `NewNodeMark` value indicates that node doesn't exist in the old children list.\n                sources[i] = -1 /* MagicValues.NewNodeMark */;\n                const j = start + i;\n                keyIndex.set(bKeys[j], j);\n            }\n            // When `nodePosition === RearrangeNodes`, it means that one of the nodes is in the wrong position and we should\n            // rearrange nodes with LIS-based algorithm `markLIS()`.\n            let nodePosition = 0;\n            for (let i = start; i <= aEnd; i++) {\n                const sChild = sChildren[i];\n                const nextPosition = keyIndex.get(aKeys[i]);\n                if (nextPosition !== void 0) {\n                    nodePosition = (nodePosition < nextPosition)\n                        ? nextPosition\n                        : 1073741823 /* MagicValues.RearrangeNodes */;\n                    sources[nextPosition - start] = i;\n                    result[nextPosition] = sChild;\n                }\n                else if (sChild !== null) {\n                    _unmount(sChild, true);\n                }\n            }\n            // Step 4\n            // Mark LIS nodes only when this node weren't moved `moveNode === false` and we've detected that one of the\n            // children nodes were moved `pos === MagicValues.MovedChildren`.\n            if (!(updateFlags & 1024 /* Flags.DisplaceNode */) && nodePosition === 1073741823 /* MagicValues.RearrangeNodes */) {\n                markLIS(sources);\n            }\n            while (bLength-- > 0) {\n                bEnd = bLength + start;\n                const node = bVNodes[bEnd];\n                const lisValue = sources[bLength];\n                result[bEnd] = (lisValue === -1)\n                    ? _mount(sNode, node)\n                    : _update(sNode, result[bEnd], node, updateFlags |\n                        ((nodePosition === 1073741823 /* MagicValues.RearrangeNodes */ && lisValue !== -2 /* MagicValues.LISMark */)\n                            ? 1024 /* Flags.DisplaceNode */\n                            : 0));\n            }\n        }\n        // Delayed update for nodes from Step 1 (prefix only). Reconciliation algorithm always updates nodes from right to\n        // left.\n        while (start > 0) {\n            result[--start] = _update(sNode, sChildren[start], bVNodes[start], updateFlags);\n        }\n    }\n    sNode.c = result;\n};\n/**\n * Modified Longest Increased Subsequence algorithm.\n *\n * Mutates input array `a` and replaces all values that are part of LIS with -2 value.\n *\n * Constraints:\n * - Doesn't work with negative numbers. -1 values are ignored.\n * - Input array `a` should contain at least one value that is greater than -1.\n *\n * {@link http://en.wikipedia.org/wiki/Longest_increasing_subsequence}\n *\n * @example\n *\n *     const A = Int32Array.from([-1, 0, 2, 1]);\n *     markLIS(A);\n *     // A => [-1, -2, 2, -2]\n *\n * @param a Array of numbers.\n * @noinline\n * @__NOINLINE__\n */\nconst markLIS = (a) => {\n    const length = a.length;\n    const parent = new _Int32Array(length);\n    const index = new _Int32Array(length);\n    let indexLength = 0;\n    let i = 0;\n    let j;\n    let k;\n    let lo;\n    let hi;\n    // Skip -1 values at the start of the input array `a`.\n    for (; a[i] === -1 /* MagicValues.NewNodeMark */; i++) { /**/ }\n    index[0] = i++;\n    for (; i < length; i++) {\n        k = a[i];\n        if (k !== -1 /* MagicValues.NewNodeMark */) { // Ignore -1 values.\n            j = index[indexLength];\n            if (a[j] < k) {\n                parent[i] = j;\n                index[++indexLength] = i;\n            }\n            else {\n                lo = 0;\n                hi = indexLength;\n                while (lo < hi) {\n                    j = (lo + hi) >> 1;\n                    if (a[index[j]] < k) {\n                        lo = j + 1;\n                    }\n                    else {\n                        hi = j;\n                    }\n                }\n                if (k < a[index[lo]]) {\n                    if (lo > 0) {\n                        parent[i] = index[lo - 1];\n                    }\n                    index[lo] = i;\n                }\n            }\n        }\n    }\n    ;\n    // Mutate input array `a` and assign -2 value to all nodes that are part of LIS.\n    j = index[indexLength];\n    while (indexLength-- >= 0) {\n        a[j] = -2 /* MagicValues.LISMark */;\n        j = parent[j];\n    }\n};\n/**\n * Creates a HTML Template cloning factory.\n *\n * @__NO_SIDE_EFFECTS__\n */\nexport const _h = (t) => (() => {\n    if (typeof t === \"string\") {\n        HTM_TEMPLATE.innerHTML = t;\n        t = HTM_TEMPLATE_CONTENT.firstChild;\n    }\n    return nodeCloneNode.call(t, true);\n});\n/**\n * Creates a HTML Template factory.\n *\n * @__NO_SIDE_EFFECTS__\n */\nexport const _hN = (t) => (() => (HTM_TEMPLATE.innerHTML = t,\n    HTM_TEMPLATE_CONTENT.firstChild));\n/**\n * Creates a HTML Element factory.\n *\n * @__NO_SIDE_EFFECTS__\n */\nexport const _hE = (t) => (() => doc.createElement(t));\n/**\n * Creates a SVG Template cloning factory.\n */\nexport const _s = (t) => (() => {\n    if (typeof t === \"string\") {\n        SVG_TEMPLATE.innerHTML = t;\n        t = SVG_TEMPLATE_CONTENT.firstChild;\n    }\n    return nodeCloneNode.call(t, true);\n});\n/**\n * Creates a SVG Template factory.\n *\n * @__NO_SIDE_EFFECTS__\n */\nexport const _sN = (t) => (() => (SVG_TEMPLATE.innerHTML = t,\n    SVG_TEMPLATE_CONTENT.firstChild));\n/**\n * Creates a SVG Element factory.\n *\n * @__NO_SIDE_EFFECTS__\n */\nexport const _sE = (t) => (() => doc.createElementNS(\"http://www.w3.org/2000/svg\", t));\n/**\n * Creates a template descriptor with globally shared data.\n *\n * @__NO_SIDE_EFFECTS__\n */\nexport const _T = (p2, f, p, c, s, d = __IVI_STRINGS__) => ({\n    f: 1 /* Flags.Template */,\n    p1: { f, p, c, s, d },\n    p2,\n});\n/**\n * @__NO_SIDE_EFFECTS__\n */\nexport const _t = (d, p) => ({ d, p });\n/**\n * Creates a factory that produces component nodes.\n *\n * @typeparam P Property type.\n * @param factory Function that produces stateful render functions.\n * @param areEqyal Function that checks `props` for equality.\n * @returns Factory that produces component nodes.\n * @__NO_SIDE_EFFECTS__\n */\nexport const component = (p1, p2) => {\n    const d = { f: 2 /* Flags.Component */, p1, p2 };\n    return (p) => ({ d, p });\n};\n/**\n * Gets current component props.\n *\n * @typeparam P Property type.\n * @param component Component node.\n * @returns Current component props.\n */\nexport const getProps = (component) => (component.v.p);\n/**\n * Adds an unmount hook.\n *\n * @example\n *\n *     const Example = component((c) => {\n *       useUnmount(c, () => { console.log(\"unmounted\"); });\n *\n *       return () => null;\n *     });\n *\n * @param component Component instance.\n * @param hook Unmount hook.\n */\nexport const useUnmount = (component, hook) => {\n    const hooks = component.s2;\n    component.s2 = (hooks === null)\n        ? hook\n        : (typeof hooks === \"function\")\n            ? [hooks, hook]\n            : (hooks.push(hook), hooks);\n};\n/**\n * Creates a side effect hook.\n *\n * @example\n *\n *     const Example = component((c) => {\n *       const [count, setCount] = useState(c, 0);\n *       const timer = useEffect(c, ({ interval }) => {\n *         const tid = setInterval(() => { setCount(count() + 1); }, interval);\n *         return () => { clearInterval(tid); };\n *       }, shallowEq);\n *\n *       return (interval) => (\n *         timer({ interval }),\n *\n *         html`<span>${count()}</span>`\n *       );\n *     });\n *\n * @typeparam T Hook props type.\n * @param component Component instance.\n * @param hook Side effect function.\n * @param areEqual Function that checks if input value hasn't changed.\n * @returns Side effect hook.\n */\nexport const useEffect = (component, hook, areEqual) => {\n    // var usage is intentional, see `docs/internals/perf.md` for an explanation.\n    var reset;\n    var prev;\n    var pending;\n    return (next) => {\n        if (pending !== true && (areEqual === void 0 ||\n            prev === void 0 ||\n            areEqual(prev, next) === false)) {\n            if (pending === void 0) {\n                useUnmount(component, () => {\n                    pending = false;\n                    if (reset !== void 0) {\n                        reset();\n                    }\n                });\n            }\n            pending = true;\n            RENDER_CONTEXT.e.push(() => {\n                if (pending === true) {\n                    pending = false;\n                    if (reset !== void 0) {\n                        reset();\n                    }\n                    reset = hook(next);\n                }\n            });\n        }\n        prev = next;\n    };\n};\nlet _layoutEffects = [];\nlet _idleEffects = [];\nconst _flushLayoutEffects = () => {\n    while (_layoutEffects.length > 0) {\n        const e = _layoutEffects;\n        _layoutEffects = [];\n        for (let i = 0; i < e.length; i++) {\n            e[i]();\n        }\n    }\n};\nconst _flushIdleEffects = () => {\n    while (_idleEffects.length > 0) {\n        const e = _idleEffects;\n        _idleEffects = [];\n        for (let i = 0; i < e.length; i++) {\n            e[i]();\n        }\n    }\n};\nexport const useLayoutEffect = (component, hook, areEqual) => {\n    // var usage is intentional, see `docs/internals/perf.md` for an explanation.\n    var reset;\n    var prev;\n    var pending;\n    return (next) => {\n        if (pending !== true && (areEqual === void 0 ||\n            prev === void 0 ||\n            areEqual(prev, next) === false)) {\n            if (pending === void 0) {\n                useUnmount(component, () => {\n                    pending = false;\n                    if (reset !== void 0) {\n                        reset();\n                    }\n                });\n            }\n            pending = true;\n            const queue = _layoutEffects;\n            if (queue.length === 0) {\n                _requestAnimationFrame(_flushLayoutEffects);\n            }\n            queue.push(() => {\n                if (pending === true) {\n                    pending = false;\n                    if (reset !== void 0) {\n                        reset();\n                    }\n                    reset = hook(next);\n                }\n            });\n        }\n        prev = next;\n    };\n};\nexport const useIdleEffect = (component, hook, areEqual) => {\n    // var usage is intentional, see `docs/internals/perf.md` for an explanation.\n    var reset;\n    var prev;\n    var pending;\n    return (next) => {\n        if (pending !== true && (areEqual === void 0 ||\n            prev === void 0 ||\n            areEqual(prev, next) === false)) {\n            if (pending === void 0) {\n                useUnmount(component, () => {\n                    pending = false;\n                    if (reset !== void 0) {\n                        reset();\n                    }\n                });\n            }\n            pending = true;\n            const queue = _idleEffects;\n            if (queue.length === 0) {\n                _requestIdleCallback(_flushIdleEffects);\n            }\n            queue.push(() => {\n                if (pending === true) {\n                    pending = false;\n                    if (reset !== void 0) {\n                        reset();\n                    }\n                    reset = hook(next);\n                }\n            });\n        }\n        prev = next;\n    };\n};\n/**\n * Invalidates a component.\n *\n * @param c Component instance.\n */\nexport const invalidate = (c) => {\n    if (!(c.f & 128 /* Flags.Dirty */)) {\n        c.f |= 128 /* Flags.Dirty */;\n        let prev = c;\n        let parent = c.p;\n        while (parent !== null) {\n            // Polymorphic call-sites\n            if (parent.f & 256 /* Flags.DirtySubtree */) {\n                return;\n            }\n            prev = parent;\n            parent.f |= 256 /* Flags.DirtySubtree */;\n            parent = parent.p;\n        }\n        prev.v.d.p1(prev, prev.s1);\n    }\n};\n/**\n * VDescriptor for List nodes.\n */\nexport const LIST_DESCRIPTOR = {\n    f: 4 /* Flags.List */,\n    p1: null,\n    p2: null,\n};\n/**\n * Creates a dynamic list.\n *\n * @typeparam E Entry type.\n * @typeparam K Key type.\n * @param entries Entries.\n * @param getKey Get key from entry function.\n * @param render Render entry function.\n * @returns Dynamic list.\n * @__NO_SIDE_EFFECTS__\n */\nexport const List = (entries, getKey, render) => ({\n    d: LIST_DESCRIPTOR,\n    p: {\n        k: entries.map(getKey),\n        v: entries.map(render),\n    },\n});\n/**\n * Performs dirty checking in a root subtree.\n *\n * When `forceUpdate` option is enabled, all components in a root subtree will\n * be updated.\n *\n * @param root Root Node.\n * @param forceUpdate Force update components.\n */\nexport const dirtyCheck = (root, forceUpdate) => {\n    _dirtyCheckRoot(root, forceUpdate === true\n        ? 512 /* Flags.ForceUpdate */\n        : 0);\n};\n/**\n * Performs a Dirty Checking in a root subtree.\n *\n * @param root Stateful Root Node.\n * @param updateFlags Update flags (ForceUpdate and DisplaceNode).\n */\nconst _dirtyCheckRoot = (root, updateFlags) => {\n    while ((updateFlags | root.f) & (256 /* Flags.DirtySubtree */ | 512 /* Flags.ForceUpdate */)) {\n        const ctx = RENDER_CONTEXT;\n        const { p, n } = ctx;\n        root.f = 32 /* Flags.Root */;\n        if (root.c !== null) {\n            const domSlot = root.v.p;\n            RENDER_CONTEXT.p = domSlot.p;\n            RENDER_CONTEXT.n = domSlot.n;\n            _dirtyCheck(root.c, updateFlags);\n            updateFlags = 0;\n            _flushDOMEffects();\n        }\n        ctx.p = p;\n        ctx.n = n;\n    }\n};\n/**\n * Updates a root subtree.\n *\n * @param root Stateful Root Node.\n * @param next New Stateless Node.\n * @param updateFlags Update flags (ForceUpdate and DisplaceNode).\n */\nconst _updateRoot = (root, next, updateFlags) => {\n    const ctx = RENDER_CONTEXT;\n    const { p, n } = ctx;\n    const domSlot = root.v.p;\n    ctx.p = domSlot.p;\n    ctx.n = domSlot.n;\n    root.f = 32 /* Flags.Root */;\n    root.c = _update(root, root.c, next, updateFlags);\n    _flushDOMEffects();\n    ctx.p = p;\n    ctx.n = n;\n    _dirtyCheckRoot(root, 0);\n};\n/**\n * Unmounts a root subtree.\n *\n * When `detach` option is enabled, root DOM nodes will be detached from the\n * DOM.\n *\n * @param root Root Node.\n * @param detach Detach root DOM nodes from the DOM.\n */\nexport const unmount = (root, detach) => {\n    if (root.c !== null) {\n        const ctx = RENDER_CONTEXT;\n        const { p, n } = ctx;\n        ctx.p = root.v.p.p;\n        root.f = 32 /* Flags.Root */;\n        _unmount(root.c, detach);\n        ctx.p = p;\n        ctx.n = n;\n    }\n};\n/**\n * Defines a root node with a custom invalidation hook.\n *\n * @param onInvalidate Invalidated Hook.\n * @returns Root Node factory.\n * @__NO_SIDE_EFFECTS__\n */\nexport const defineRoot = (p1) => {\n    var d = { f: 32 /* Flags.Root */, p1, p2: null };\n    return (p, n = null, s) => createSNode(32 /* Flags.Root */, \n    // VNode object.\n    {\n        // Root Descriptor.\n        d,\n        // VNode props object contains the location in the DOM tree where subtree\n        // should be rendered.\n        p: {\n            // Parent DOM Element.\n            p,\n            // Next DOM Node.\n            n,\n        },\n    }, \n    // Children.\n    null, \n    // Parent SNode.\n    null, \n    // Root state.\n    s);\n};\n/**\n * Creates a root node that uses microtask queue for scheduling updates.\n *\n * @param parentElement Parent DOM Element.\n * @param nextNode Next DOM Node.\n * @returns Root Node.\n */\nexport const createRoot = /*@__PURE__*/ defineRoot(\n// OnRootInvalidated hook\n(root) => {\n    // Schedules a microtask for dirty checking.\n    _queueMicrotask(() => {\n        _dirtyCheckRoot(root, 0);\n    });\n});\n/**\n * Updates a root subtree.\n *\n * When `forceUpdate` option is enabled, all components in a root subtree will\n * be updated.\n *\n * @param root Root Node.\n * @param v Stateless View Node.\n * @param forceUpdate Force update components.\n */\nexport const update = (root, v, forceUpdate) => {\n    _updateRoot(root, v, forceUpdate === true\n        ? 512 /* Flags.ForceUpdate */\n        : 0);\n};\n/**\n * Context.\n *\n * @returns Context getter and context provider.\n * @__NO_SIDE_EFFECTS__\n */\nexport const context = () => {\n    const d = { f: 64 /* Flags.Context */, p1: null, p2: null };\n    return [\n        (c) => _getContextValue(c, d),\n        (v, c) => ({ d, p: { v, c } }),\n    ];\n};\nconst _getContextValue = (c, d) => {\n    let node = c.p;\n    while (node !== null) {\n        if (node.f & 64 /* Flags.Context */ && node.v.d === d) {\n            return node.v.p.v;\n        }\n        node = node.p;\n    }\n};\n//# sourceMappingURL=core.js.map","import { invalidate } from \"./core.js\";\n/**\n * Creates a memoized function.\n *\n * @example\n *\n *     const Example = component((c) => {\n *       const fullName = useMemo(shallowEqArray, ([firstName, lastName]) => (\n *         `${firstName} ${lastName}`\n *       ));\n *\n *       return ({firstName, lastName}) => html`\n *         div.fullName ${fullName([firstName, lastName])}\n *       `;\n *     });\n *\n * @typeparam T Input type.\n * @typeparam U Output type.\n * @param areEqual Function that checks if input value hasn't changed.\n * @param fn Function to memoize.\n * @returns Memoized function.\n */\nexport const useMemo = (areEqual, fn) => {\n    var prev;\n    var v;\n    return (props) => ((v === void 0 || areEqual(prev, props) === false)\n        ? v = fn(prev = props)\n        : v);\n};\n/**\n * Creates a reactive state.\n *\n * @example\n *\n *     const Example = component((c) => {\n *       const [getCounter, setCounter] = useState(c, 0);\n *       const inc = () => { setCounter(getCounter() + 1); };\n *\n *       return () => html`\n *         div.app\n *           div.counter ${getCounter()}\n *           button @click=${inc} 'Increment'\n *       `;\n *     });\n *\n * @typeparam S State type.\n * @param component Component instance.\n * @param state Initial state value.\n * @returns A tuple with a getter and setter functions.\n */\nexport const useState = (component, state) => ([\n    // getter\n    () => state,\n    // setter\n    (next) => {\n        if (next !== state) {\n            state = next;\n            invalidate(component);\n        }\n    }\n]);\n/**\n * Creates a reactive state reducer.\n *\n * @example\n *\n *     function reducer(state, action) {\n *       switch (action.type) {\n *         case \"inc\":\n *           return state + 1;\n *       }\n *       return state;\n *     }\n *\n *     const Example = component((c) => {\n *        const [counter, dispatch] = useReducer(c, 0, reducer);\n *        const inc = () => { dispatch(\"inc\"); };\n *\n *       return () => html`\n *         div.app\n *           div.counter ${counter()}\n *           button @click=${inc} 'Increment'\n *       `;\n *     });\n *\n * @typeparam S State type.\n * @typeparam A Reducer action type.\n * @param component Component instance.\n * @param state Initial state.\n * @param reducer Reducer function.\n * @returns State getter and dispatch functions.\n */\nexport const useReducer = (component, state, reducer) => ([\n    () => state,\n    (action) => {\n        const nextState = reducer(state, action);\n        if (state !== nextState) {\n            state = nextState;\n            invalidate(component);\n        }\n        return state;\n    }\n]);\n//# sourceMappingURL=state.js.map","/**\n* Copyright (c) 2025, Leon Sorokin\n* All rights reserved. (MIT Licensed)\n*\n* uDSV.js\n* A small, fast CSV parser\n* https://github.com/leeoniya/uDSV (v0.7.2)\n*/\n\nconst comma = ',';\nconst quote = '\"';\nconst tab   = '\\t';\nconst pipe  = '|';\nconst semi  = ';';\n\nconst ISO8601 = /^\\d{4}-\\d{2}-\\d{2}(?:T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d{3,})?(?:Z|[-+]\\d{2}:?\\d{2}))?$/;\nconst BOOL_RE = /^(?:t(?:rue)?|f(?:alse)?|y(?:es)?|n(?:o)?|0|1)$/i;\n\nconst COL_DELIMS = [tab, pipe, semi, comma];\n\nfunction stripBOM(str) {\n\treturn str.charCodeAt(0) === 0xFEFF ? str.slice(1) : str;\n}\n\nfunction boolTrue(v) {\n\tlet [c0, c1 = ''] = v;\n\n\treturn (\n\t\tc0 == '1' || c0 == '0' ? '1' :\n\n\t\tc0 == 't' || c0 == 'f' ? (c1 == '' ? 't' : 'true') :\n\t\tc0 == 'T' || c0 == 'F' ? (c1 == '' ? 'T' : c1 == 'R' || c1 === 'A' ? 'TRUE' : 'True') :\n\n\t\tc0 == 'y' || c0 == 'n' ? (c1 == '' ? 'y' : 'yes') :\n\t\tc0 == 'Y' || c0 == 'N' ? (c1 == '' ? 'Y' : c1 == 'E' || c1 === 'O' ? 'YES'  : 'Yes')  :\n\n\t\t''\n\t);\n}\n\nfunction isJSON(v) {\n\tif (v[0] === '[' || v[0] === '{') {\n\t\ttry {\n\t\t\tJSON.parse(v);\n\t\t\treturn true;\n\t\t} catch {}\n\t}\n\n\treturn false;\n}\n\nconst T_STRING  = 's';\nconst T_DATE    = 'd';\nconst T_TIME    = 't';\nconst T_NUMBER  = 'n';\nconst T_JSON    = 'j';\nconst T_BOOLEAN = 'b';\n\nfunction guessType(ci, rows) {\n\t// row with a value to analyze\n\tlet row = rows.findLast(r =>\n\t\tr[ci] !== ''     &&\n\t\tr[ci] !== 'null' &&\n\t\tr[ci] !== 'NULL' &&\n\t\tr[ci] !== 'NaN'\n\t);\n\n\tlet t = T_STRING;\n\n\tif (row != null) {\n\t\tlet v = row[ci];\n\n\t\tt = (\n\t\t\tISO8601.test(v) ? T_DATE                        :\n\t\t\t+v === +v       ? T_NUMBER                      :\n\t\t\tBOOL_RE.test(v) ? T_BOOLEAN + ':' + boolTrue(v) :\n\t\t\tisJSON(v)       ? T_JSON                        :\n\t\t\tt\n\t\t);\n\t}\n\n\treturn t;\n}\n\nconst toJSON = JSON.stringify;\nconst onlyStrEsc = v => typeof v === 'string' ? toJSON(v) : v;\n\nfunction getValParseExpr(ci, col) {\n\tlet { type, parse } = col;\n\n\tlet rv = `r[${ci}]`;\n\n\tlet parseExpr =\n\t    parse   !=  null      ? `c[${ci}].parse(${rv})`                             :\n\t\ttype    === T_DATE    ? `new Date(${rv})`                                   :\n\t\ttype    === T_TIME    ? `Date.parse(${rv})`                                 :\n\t\ttype    === T_JSON    ? `JSON.parse(${rv})`                                 :\n\t\ttype    === T_NUMBER  ? `+${rv}`                                            :\n\t\ttype[0] === T_BOOLEAN ? `${rv} === ${toJSON(type.slice(2))} ? true : false` :\n\t\trv;\n\n\tlet { repl } = col;\n\n\tlet nanExpr   = repl.NaN   !== void 0 && type === T_NUMBER ? `${rv} === 'NaN' ? ${onlyStrEsc(repl.NaN)} : `                       : '';\n\tlet nullExpr  = repl.null  !== void 0                      ? `${rv} === 'null' || ${rv} === 'NULL' ? ${onlyStrEsc(repl.null)} : ` : '';\n\tlet emptyExpr = repl.empty !== void 0                      ? `${rv} === '' ? ${onlyStrEsc(repl.empty)} : `                        : '';\n\n\treturn `${emptyExpr} ${nullExpr} ${nanExpr} ${parseExpr}`;\n}\n\nconst segsRe = /\\w+(?:\\[|\\]?[\\.\\[]?|$)/gm;\n\nfunction genToTypedRow(cols, objs = false, deep = false) {\n\tlet buf = '';\n\n\tif (objs && deep) {\n\t\tlet tplObj = {};\n\t\tlet colIdx = 0;\n\n\t\tlet paths = cols.map(c => c.name.replace(/\\.(\\d+)\\.?/gi, '[$1]'));\n\n\t\tdo {\n\t\t\tlet path = paths.shift();\n\n\t\t\tlet segs = /\\s/.test(path) ? [path] : [...path.matchAll(segsRe)].flatMap(m => m.map(m => m.replace(']', '')));\n\n\t\t\tlet node = tplObj;\n\t\t\tdo {\n\t\t\t\tlet seg = segs.shift();\n\n\t\t\t\tlet key = seg;\n\t\t\t\tlet endChar = seg.at(-1);\n\t\t\t\tlet hasKids = endChar == '.' || endChar == '[';\n\n\t\t\t\tif (hasKids) {\n\t\t\t\t\tkey = seg.slice(0, -1);\n\t\t\t\t\tlet nextNode = node[key] ?? (endChar == '.' ? {} : []);\n\t\t\t\t\tnode = node[key] = nextNode;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tnode[key] = `¦${colIdx}¦`;\n\t\t\t} while (segs.length > 0);\n\n\t\t\tcolIdx++;\n\t\t} while (paths.length > 0);\n\n\t\tbuf = toJSON(tplObj).replace(/\"¦(\\d+)¦\"/g, (m, ci) => getValParseExpr(+ci, cols[+ci]));\n\t}\n\telse {\n\t\tif (!objs && cols.every(c => c.type === T_STRING))\n\t\t\tbuf = 'r';\n\t\telse {\n\t\t\tbuf = objs ? '{' : '[';\n\n\t\t\tcols.forEach((col, ci) => {\n\t\t\t\tbuf += objs ? `${toJSON(col.name)}:` : '';\n\t\t\t\tlet parseVal = getValParseExpr(ci, col);\n\t\t\t\tbuf += `${parseVal},`;\n\t\t\t});\n\n\t\t\tbuf += objs ? '}' : ']';\n\t\t}\n\t}\n\n\treturn new Function('c', `return r => (${buf});`)(cols);\n}\n\n// https://www.loc.gov/preservation/digital/formats/fdd/fdd000323.shtml\nfunction inferSchema(csvStr, opts, maxRows) {\n\tlet {\n\t\theader: headerFn,\n\t\tcol:    colDelim,\n\t\trow:    rowDelim,\n\t\tencl:   colEncl,\n\t\tesc:    escEncl,\n\t//\tomit,  // #comments and empty lines (ignore:), needs callback for empty and comments?\n\t\ttrim  = false,\n\t} = opts ?? {};\n\n\t// by default, grab first row, and skip it\n\theaderFn ??= firstRows => [firstRows[0]];\n\n\tmaxRows ??= 10;\n\n\tcsvStr = stripBOM(csvStr);\n\n\t// will fail if header contains line breaks in quoted value\n\t// will fail if single line without line breaks\n\tconst rowRE         = new RegExp(`(.*)(${rowDelim ?? '\\r\\n|\\r|\\n'})`);\n\tconst firstRowMatch = csvStr.match(rowRE);\n\tconst firstRowStr   = firstRowMatch[1];\n\n\trowDelim ??= firstRowMatch[2];\n\tcolDelim ??= COL_DELIMS.find(delim => firstRowStr.indexOf(delim) > -1) ?? comma;\n\n\tconst schema = {\n\t\tskip: 1, // how many header rows to skip\n\t\tcol:  colDelim,\n\t\trow:  rowDelim,\n\t\tencl: colEncl,\n\t\tesc:  escEncl,\n\t\ttrim: trim,\n\t\tcols: [],\n\t};\n\n\tconst _maxCols = firstRowStr.split(colDelim).length;\n\n\tconst firstRows = [];\n\tparse(csvStr, schema, 0, row => {\n\t\tfirstRows.push(row);\n\t\treturn firstRows.length < maxRows;\n\t}, true, _maxCols);\n\n\tlet headerRows = headerFn(firstRows) ?? [];\n\n\tlet skip = schema.skip = headerRows.length;\n\n\t// first non-null row\n\tlet colNames = headerRows.find(row => row != null) ?? [...Array(firstRows[0].length).keys()];\n\n\tfirstRows.splice(0, skip);\n\n\tcolNames.forEach((colName, colIdx) => {\n\t\tlet type = guessType(colIdx, firstRows);\n\n\t\tlet col = {\n\t\t\tname: colName,\n\t\t\ttype,\n\t\t\t// this could be type-dependant (e.g. {empty: 0, null: 0, NaN: NaN} for numbers)\n\t\t\trepl: {\n\t\t\t\tempty: null,\n\t\t\t\tNaN: void 0,\n\t\t\t\tnull: void 0,\n\t\t\t},\n\t\t};\n\n\t\tschema.cols.push(col);\n\t});\n\n\treturn schema;\n}\n\nfunction initParser(schema) {\n\tlet { skip, cols } = schema;\n\n\tlet _toStr = null;\n\tlet _toArr = null;\n\tlet _toObj = null;\n\tlet _toDeep = null;\n\tlet _toObjS = null;\n\n\tlet streamState = 0;\n\tlet streamParse = null;\n\tlet streamCb = null;\n\tlet prevUnparsed = '';\n\n\tlet buf = null;\n\n\tfunction reset() {\n\t\tstreamState = 0;\n\t\tprevUnparsed = '';\n\t\tstreamParse = streamCb = buf = null;\n\t}\n\n\tlet accum    = (row, buf, add) => {\n\t\tadd(buf, row);\n\t\treturn true;\n\t};\n\tlet initRows = () => [];\n\tlet initCols = () => cols.map(c => []);\n\tlet addRow  = (buf, row) => { buf.push(row); };\n\tlet addCol  = new Function('buf', 'row', `\n\t\t${schema.cols.map((c, i) => 'buf[' + i + '].push(row[' + i + '])').join(';')};\n\t`);\n\n\tfunction gen(accInit, accAppend, genConvertRow) {\n\t\tlet convertRow = null;\n\n\t\treturn (csvStr, cb = accum) => {\n\t\t\tconvertRow ??= genConvertRow();\n\n\t\t\tlet _skip = buf == null ? skip : 0;\n\n\t\t\tbuf ??= accInit();\n\t\t\tlet out = buf;\n\t\t\tlet withEOF = streamState === 0 || streamState === 2;\n\n\t\t\tlet halted = false;\n\n\t\t\tif (Array.isArray(csvStr)) {\n\t\t\t\tfor (let i = 0; i < csvStr.length; i++) {\n\t\t\t\t\tlet row = csvStr[i];\n\t\t\t\t\tlet res = cb(convertRow(row), out, accAppend);\n\n\t\t\t\t\tif (res === false) {\n\t\t\t\t\t\thalted = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\t[prevUnparsed, halted] = parse(csvStr, schema, _skip, row => cb(convertRow(row), out, accAppend), withEOF);\n\n\t\t\tif (halted && streamState !== 0)\n\t\t\t\treset();\n\n\t\t\tif (withEOF)\n\t\t\t\tbuf = null;\n\n\t\t\treturn out;\n\t\t};\n\t}\n\n\tconst _toStrGen = () => {\n\t\t_toStr ??= row => row;\n\t\treturn _toStr;\t};\n\n\tconst _toArrGen = () => {\n\t\t_toArr ??= genToTypedRow(cols, false, false);\n\t\treturn _toArr;\n\t};\n\n\tconst stringArrs = gen(initRows, addRow, _toStrGen);\n\n\tconst stringObjs = gen(initRows, addRow, () => {\n\t\t_toObjS ??= genToTypedRow(cols.map(col => ({\n\t\t\t...col,\n\t\t\ttype: 's',\n\t\t\trepl: {\n\t\t\t\t...col.repl,\n\t\t\t\tempty: void 0,\n\t\t\t}\n\t\t})), true, false);\n\n\t\treturn _toObjS;\n\t});\n\n\tconst typedArrs = gen(initRows, addRow, _toArrGen);\n\n\tconst typedObjs = gen(initRows, addRow, () => {\n\t\t_toObj ??= genToTypedRow(cols, true, false);\n\t\treturn _toObj;\n\t});\n\n\tconst typedDeep = gen(initRows, addRow, () => {\n\t\t_toDeep ??= genToTypedRow(cols, true, true);\n\t\treturn _toDeep;\n\t});\n\n\tconst typedCols = gen(initCols, addCol, _toArrGen);\n\n\tconst stringCols = gen(initCols, addCol, _toStrGen);\n\n\treturn {\n\t\tschema,\n\n\t\tstringArrs,\n\t\tstringObjs,\n\t\tstringCols,\n\n\t\ttypedArrs,\n\t\ttypedObjs,\n\t\ttypedDeep,\n\t\ttypedCols,\n\n\t\tchunk(csvStr, parse = stringArrs, cb = accum) {\n\t\t\tstreamParse ??= parse;\n\t\t\tstreamCb    ??= cb;\n\n\t\t\tstreamState = 1;\n\t\t\tstreamParse(prevUnparsed + csvStr, streamCb);\n\t\t},\n\t\tend() {\n\t\t\tstreamState = 2;\n\t\t\tlet out = streamParse(prevUnparsed, streamCb);\n\t\t\treset();\n\t\t\treturn out;\n\t\t},\n\t};\n}\n\n// todo: allow schema to have col.skip: true\n// _maxCols is cols estimated by simple delimiter detection and split()\n// returns [unparsed tail, shouldHalt]\nfunction parse(csvStr, schema, skip = 0, each = () => true, withEOF = true, _maxCols) {\n\tcsvStr = stripBOM(csvStr);\n\n\tlet {\n\t\trow:  rowDelim,\n\t\tcol:  colDelim,\n\t\tencl: colEncl,\n\t\tesc:  escEncl,\n\t\ttrim,\n\t} = schema;\n\n\t// is this cheap in WebKit/Mozilla, would simplify exit conditions\n\t// if (withEOF && !csvStr.endsWith(rowDelim))\n\t// \tcsvStr += rowDelim;\n\n\tcolEncl ??= csvStr.indexOf(quote) > -1 ? quote : ''; \t// TODO: detect single quotes?\n\tescEncl ??= colEncl;\n\n\tlet replEsc = `${escEncl}${colEncl}`;\n\n\tlet numCols = _maxCols ?? schema.cols.length;\n\n\t// uses a slower regexp path for schema probing\n\tlet _probe = _maxCols != null;\n\n\tlet rowDelimLen = rowDelim.length;\n\tlet colDelimLen = colDelim.length;\n\n\tlet colEnclChar  = colEncl.charCodeAt(0);\n\tlet escEnclChar  = escEncl.charCodeAt(0);\n\tlet rowDelimChar = rowDelim.charCodeAt(0);\n\tlet colDelimChar = colDelim.charCodeAt(0);\n\tlet spaceChar    = 32;\n\n\tlet out = ['', false];\n\n\tlet pos = 0;\n\tlet endPos = csvStr.length - 1;\n\tlet linePos = 0;\n\n\tlet rowTpl = Array(numCols).fill('');\n\tlet row = rowTpl.slice();\n\n\tlet colIdx = 0;\n\tlet lastColIdx = numCols - 1;\n\tlet filledColIdx = -1;\n\n\tif (colEncl === '') {\n\t\twhile (pos <= endPos) {\n\t\t\tif (colIdx === lastColIdx) {\n\t\t\t\tlet pos2 = csvStr.indexOf(rowDelim, pos);\n\n\t\t\t\tif (pos2 === -1) {\n\t\t\t\t\tif (!withEOF)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tpos2 = endPos + 1;\n\t\t\t\t}\n\n\t\t\t\tlet s = csvStr.slice(pos, pos2);\n\t\t\t\trow[colIdx] = trim ? s.trim() : s;\n\n\t\t\t\tif (--skip < 0) {\n\t\t\t\t\tif (each(row) === false) {\n\t\t\t\t\t\t// if caller indicates an early exit, we dont return the unparsed tail\n\t\t\t\t\t\tout[1] = true;\n\t\t\t\t\t\treturn out;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trow = rowTpl.slice();\n\t\t\t\tcolIdx = 0;\n\t\t\t\tfilledColIdx = -1;\n\t\t\t\tpos = pos2 + rowDelimLen;\n\t\t\t\tlinePos = pos;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// empty line\n\t\t\t\tif (colIdx === 0 && csvStr.charCodeAt(pos) === rowDelimChar) {\n\t\t\t\t\tpos += rowDelimLen;\n\t\t\t\t\t// TODO: callback here!\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlet pos2 = csvStr.indexOf(colDelim, pos);\n\n\t\t\t\t\tif (pos2 === -1) {\n\t\t\t\t\t\tif (!withEOF)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet s = csvStr.slice(pos, pos2);\n\t\t\t\t\trow[colIdx] = trim ? s.trim() : s;\n\t\t\t\t\tpos = pos2 + colDelimLen;\n\t\t\t\t\tfilledColIdx = colIdx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (--skip < 0 && withEOF && colIdx === lastColIdx && filledColIdx > -1)\n\t\t\teach(row);\n\n\t\tout[0] = !withEOF ? csvStr.slice(linePos) : '';\n\t\treturn out;\n\t}\n\n\t// should this be * to handle ,, ?\n\tconst takeToCommaOrEOL = _probe ? new RegExp(`[^${colDelim}${rowDelim}]+`, 'my') : null;\n\n\t// 0 = no\n\t// 1 = unquoted\n\t// 2 = quoted\n\tlet inCol = 0;\n\n\tlet v = '';\n\tlet c = 0;\n\n\tlet pos0 = pos;\n\n\twhile (pos <= endPos) {\n\t\tc = csvStr.charCodeAt(pos);\n\n\t\tif (inCol === 0) {\n\t\t\tif (c === colEnclChar) {\n\t\t\t\tinCol = 2;\n\t\t\t\tpos += 1;\n\t\t\t\tpos0 = pos;\n\n\t\t\t\tif (pos > endPos)\n\t\t\t\t\tbreak;\n\n\t\t\t\tc = csvStr.charCodeAt(pos);\n\t\t\t}\n\t\t\telse if (c === colDelimChar || c === rowDelimChar) {\n\t\t\t\t// PUSH MACRO START\n\t\t\t\tif (c === rowDelimChar && colIdx === 0) {\n\t\t\t\t\tpos += rowDelimLen;\n\t\t\t\t\t// TODO: callback here!\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\trow[colIdx] = v;\n\t\t\t\tfilledColIdx = colIdx;\n\t\t\t\tcolIdx += 1;\n\n\t\t\t\tpos += 1;\n\t\t\t\tv = '';\n\n\t\t\t\tif (c === rowDelimChar) {\n\t\t\t\t\tif (_probe && filledColIdx < lastColIdx && linePos === 0) {\n\t\t\t\t\t\trow.length = rowTpl.length = filledColIdx + 1;\n\t\t\t\t\t\tlastColIdx = filledColIdx;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (--skip < 0) {\n\t\t\t\t\t\tif (each(row) === false) {\n\t\t\t\t\t\t\t// if caller indicates an early exit, we dont return the unparsed tail\n\t\t\t\t\t\t\tout[1] = true;\n\t\t\t\t\t\t\treturn out;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\trow = rowTpl.slice();\n\t\t\t\t\tcolIdx = 0;\n\t\t\t\t\tfilledColIdx = -1;\n\t\t\t\t\tpos += rowDelimLen - 1;\n\t\t\t\t\tlinePos = pos;\n\t\t\t\t}\n\t\t\t\t// PUSH MACRO END\n\n\t\t\t\tif (pos > endPos)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (trim && c === spaceChar) {\n\t\t\t\t\twhile (c === spaceChar)\n\t\t\t\t\t\tc = csvStr.charCodeAt(++pos);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tinCol = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (inCol === 2) {\n\t\t\tlet shouldRep = false;\n\t\t\tlet posTo = 0;\n\n\t\t\twhile (true) {\n\t\t\t\tif (c === colEnclChar) {\n\t\t\t\t\tif (colEnclChar === escEnclChar) {\n\t\t\t\t\t\tif (pos + 1 > endPos) { // TODO: test with chunk ending in closing \", even at EOL but not EOF\n\t\t\t\t\t\t\tposTo = pos;\n\t\t\t\t\t\t\tpos = endPos + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet cNext = csvStr.charCodeAt(pos + 1);\n\n\t\t\t\t\t\tif (cNext === colEnclChar) {\n\t\t\t\t\t\t\tpos += 2;\n\n\t\t\t\t\t\t\t// MACRO START\n\t\t\t\t\t\t\tshouldRep = true;\n\t\t\t\t\t\t\tif (pos > endPos)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tc = csvStr.charCodeAt(pos);\n\t\t\t\t\t\t\t// MACRO END\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tinCol = 0;\n\t\t\t\t\t\t\tposTo = pos;\n\t\t\t\t\t\t\tpos += 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet cPrev = csvStr.charCodeAt(pos - 1);\n\n\t\t\t\t\t\tif (cPrev === escEnclChar) {\n\t\t\t\t\t\t\tpos += 1;\n\n\t\t\t\t\t\t\t// MACRO START\n\t\t\t\t\t\t\tshouldRep = true;\n\t\t\t\t\t\t\tif (pos > endPos)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tc = csvStr.charCodeAt(pos);\n\t\t\t\t\t\t\t// MACRO END\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tinCol = 0;\n\t\t\t\t\t\t\tposTo = pos;\n\t\t\t\t\t\t\tpos += 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlet pos2 = csvStr.indexOf(colEncl, pos);\n\n\t\t\t\t\tif (pos2 === -1) {\n\t\t\t\t\t\tpos = endPos + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tpos = pos2;\n\t\t\t\t\tc = colEnclChar;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (inCol === 0 || pos > endPos) {\n\t\t\t\tv = shouldRep ?\n\t\t\t\t\tcsvStr.slice(pos0, posTo).replaceAll(replEsc, colEncl) :\n\t\t\t\t\tcsvStr.slice(pos0, posTo);\n\t\t\t}\n\t\t}\n\t\telse if (inCol === 1) {\n\t\t\tif (c === colDelimChar || c === rowDelimChar) {\n\t\t\t\t// PUSH MACRO START\n\t\t\t\tif (c === rowDelimChar && colIdx === 0) {\n\t\t\t\t\tpos += rowDelimLen;\n\t\t\t\t\t// TODO: callback here!\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\trow[colIdx] = v;\n\t\t\t\tfilledColIdx = colIdx;\n\t\t\t\tcolIdx += 1;\n\n\t\t\t\tpos += 1;\n\t\t\t\tv = '';\n\n\t\t\t\tif (c === rowDelimChar) {\n\t\t\t\t\tif (_probe && filledColIdx < lastColIdx && linePos === 0) {\n\t\t\t\t\t\trow.length = rowTpl.length = filledColIdx + 1;\n\t\t\t\t\t\tlastColIdx = filledColIdx;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (--skip < 0) {\n\t\t\t\t\t\tif (each(row) === false) {\n\t\t\t\t\t\t\t// if caller indicates an early exit, we dont return the unparsed tail\n\t\t\t\t\t\t\tout[1] = true;\n\t\t\t\t\t\t\treturn out;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\trow = rowTpl.slice();\n\t\t\t\t\tcolIdx = 0;\n\t\t\t\t\tfilledColIdx = -1;\n\t\t\t\t\tpos += rowDelimLen - 1;\n\t\t\t\t\tlinePos = pos;\n\t\t\t\t}\n\t\t\t\t// PUSH MACRO END\n\n\t\t\t\tinCol = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (_probe) {\n\t\t\t\t\ttakeToCommaOrEOL.lastIndex = pos;\n\t\t\t\t\tlet m = takeToCommaOrEOL.exec(csvStr)[0];\n\t\t\t\t\tv = m;\n\t\t\t\t\tpos += m.length;  // rowdelim when - 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlet pos2 = csvStr.indexOf(colIdx === lastColIdx ? rowDelim : colDelim, pos);\n\n\t\t\t\t\tif (pos2 === -1)\n\t\t\t\t\t\tpos2 = endPos + 1;\n\n\t\t\t\t\tlet s = csvStr.slice(pos, pos2);\n\t\t\t\t\tv = trim ? s.trim() : s;\n\t\t\t\t\tpos = pos2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (withEOF && colIdx === lastColIdx) {\n\t\trow[colIdx] = v;\n\n\t\tif (--skip < 0)\n\t\t\teach(row);\n\n\t\tinCol = 0;\n\t}\n\n\tlet partial = !withEOF && (\n\t\tinCol !== 0 ||\n\t\t(\n\t\t\tfilledColIdx === -1 ? v !== '' :  // partial first col OR\n\t\t\tfilledColIdx < lastColIdx         // not all cols filled\n\t\t)\n\t);\n\n\tout[0] = partial ? csvStr.slice(linePos) : '';\n\treturn out;\n}\n\n// const parsed = {\n// \tformat: '',\n// \tdata: []\n// };\n\nexport { inferSchema, initParser };\n","const cleanRHS = v => JSON.stringify(v);\nconst cleanLHS = (path, chain = false) => {\n  if (path == null || path == '' || path == '$' || path == '$i')\n    return path;\n\n  let cleanPath = '';\n\n  // guard against access outside of scope\n  if (path[0] == '.' || path[0] == '[') {\n    // remove baddies\n    cleanPath = path.replace(/[^$\\w.?\\[\\]-]/ig, '');\n\n    // add optional chaining\n    if (chain) {\n      cleanPath = cleanPath\n        .replace(/\\.\\??/ig, '.?')\n        .replace(/(?:\\.\\?)?\\[/ig, '.?[');\n    }\n  }\n\n  return '$' + cleanPath;\n}\n\nconst EMPTY_ARR = [];\nconst EMPTY_OBJ = {};\n\nlet OPTS = { chain: false, ops: EMPTY_OBJ };\n\nexport function compileExpr(node, opts = OPTS, stmts = []) {\n  let op = node[0];\n  let lhs = node[1];\n  let rhs = node[2];\n\n  let expr = '';\n\n  let negate = op[0] == '!' && op != '!=' && op != '!==' && op != '!!' && op != '!';\n\n  op = negate ? op.slice(1) : op;\n\n  let $ops = opts.ops ?? EMPTY_OBJ;\n\n  if (typeof $ops[op] == 'function' && /^\\w+$/.test(op)) {\n    stmts.push(`let $args = ${JSON.stringify(lhs ?? null)};`);\n    expr = `$ops.${op}($, $i, $args)`;\n  }\n  else {\n    let path = op != '&&' && op != '||' ? cleanLHS(lhs, opts.chain) : '';\n\n    switch (op) {\n      case '&&':\n      case '||':\n        let exprs = node.slice(1).map(node2 => compileExpr(node2, opts, stmts));\n        expr = exprs.length > 1 ? `(${exprs.map(o => o.expr).join(` ${op} `)})` : exprs[0].expr;\n        break;\n\n      case 'truthy':\n      case '!!':\n        expr = `Boolean(${path})`;\n        break;\n      case 'falsy':\n      case '!':\n        expr = `!Boolean(${path})`;\n        break;\n\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n      case '>=':\n      case '<=':\n      case '<':\n      case '>':\n        expr = `${path} ${op} ${cleanRHS(rhs)}`;\n        break;\n\n      case 'some':\n      case 'every':\n        expr = `${path}.${op}(($, $i) => ${compileExpr(rhs, opts, stmts).expr})`;\n        break;\n\n      case ',':\n      case 'in':\n        expr = `$${stmts.length}.has(${path})`;\n        stmts.push(`let $${stmts.length} = new Set(${cleanRHS(rhs)});`);\n        break;\n\n      case '-':\n      case '[]':\n      case '()':\n      case '[)':\n      case '(]':\n        if (!Array.isArray(rhs)) break;\n\n        let [min, max] = rhs;\n        let [l, r] = op;\n        let lop = l == '[' || l == '-' ? '>=' : '>';\n        let rop = r == ']' || r == null ? '<=' : '<';\n        expr = `${path} ${lop} ${cleanRHS(min)} && ${path} ${rop} ${cleanRHS(max)}`;\n        break;\n\n      case 'startsWith':\n      case '^':\n        expr = `${path}.startsWith(${cleanRHS(rhs)})`;\n        break;\n\n      case 'endsWith':\n      case '$':\n        expr = `${path}.endsWith(${cleanRHS(rhs)})`;\n        break;\n\n      case 'includes':\n      case '*':\n        expr = `${path}.includes(${cleanRHS(rhs)})`;\n        break;\n\n      case 'regexp':\n      case 'regexpi':\n      case '/':\n      case '/i':\n        let flags = op.at(-1) == 'i' ? 'i' : '';\n        expr = `$${stmts.length}.test(${path})`;\n        stmts.push(`let $${stmts.length} = new RegExp(${cleanRHS(rhs)}, \"${flags}\");`);\n        break;\n\n      case 'isInteger':\n      case 'isFinite':\n      case 'isNaN':\n        expr = `Number.${op}(${path})`;\n        break;\n\n      case 'isArray':\n        expr = `Array.isArray(${path})`;\n        break;\n    }\n  }\n\n  expr = negate ? `!(${expr})` : expr;\n\n  return {\n    stmts,\n    expr\n  };\n}\n\nexport function compileMatcher(nodes, opts = OPTS) {\n  let { expr, stmts } = compileExpr(nodes, opts);\n\n  return new Function('$ops', `\n    ${stmts.join('\\n')};\n    return ($, $i = 0) => ${expr};\n  `)(opts.ops ?? EMPTY_OBJ);\n}\n\n/*\n// these are for loop exits\ncase 'all'\ncase 'first': // early break after count\ncase 'last':  // backwards early break\n  lhs = node[1]; // howMany\n  rhs = node[2];\ncase 'only':  // early return nothing if count > 1\n*/\n\nfunction _compileFilter(nodes, opts = OPTS, useIdx = false) {\n  let { expr, stmts } = compileExpr(nodes, opts);\n\n  return new Function('$ops', `\n    ${stmts.join('\\n')}\n    return arr => {\n      let out = [];\n      for (let $i = 0; $i < arr.length; $i++) {\n        let $ = arr[$i];\n        ${expr} && out.push(${useIdx ? '$i' : '$'});\n      }\n      return out;\n    };\n  `)(opts.ops ?? EMPTY_OBJ);\n}\n\n// objs struct should be like {\"prop\": [1,2,3,4], \"other\": ['a','b','c']}\nexport function compileExprCols(nodes, names = EMPTY_ARR, opts = OPTS) {\n  let { expr, stmts } = compileExpr(nodes, opts);\n\n  if (names.length > 0) {\n    names.forEach((name, i) => {\n      if (!/[^\\w.]/.test(name)) {\n        expr = expr.replaceAll(name, `[${i}][$i]`);\n      }\n    });\n  }\n\n  return { expr, stmts };\n}\n\nexport function compileMatcherCols(nodes, names, opts = OPTS) {\n  let { expr, stmts } = compileExprCols(nodes, names, opts);\n\n  return new Function('$ops', `\n    ${stmts.join('\\n')};\n    return ($, $i = 0) => ${expr};\n  `)(opts.ops ?? EMPTY_OBJ);\n}\n\nconst filterColsIdxsBody = expr => `\n      let len = cols[0].length;\n\n      let $ = cols;\n      let idxs = [];\n\n      for (let $i = 0; $i < len; $i++) {\n        ${expr} && idxs.push($i);\n      }\n`;\n\nexport function compileFilterColsIdxs(nodes, names, opts = OPTS) {\n  let { expr, stmts } = compileExprCols(nodes, names, opts);\n\n  return new Function('$ops', `\n    ${stmts.join('\\n')}\n    return cols => {\n      ${filterColsIdxsBody(expr)}\n      return idxs;\n    };\n  `)(opts.ops ?? EMPTY_OBJ);\n}\n\nexport function compileFilterCols(nodes, names, opts = OPTS) {\n  let { expr, stmts } = compileExprCols(nodes, names, opts);\n\n  return new Function('$ops', `\n    ${stmts.join('\\n')}\n    return cols => {\n      ${filterColsIdxsBody(expr)}\n\n      return cols.map(col => {\n        let fcol = [];\n\n        for (let i = 0; i < idxs.length; i++) {\n          fcol.push(col[idxs[i]]);\n        }\n\n        return fcol;\n      });\n    };\n  `)(opts.ops ?? EMPTY_OBJ);\n}\n\nexport const compileFilter = (nodes, opts = OPTS) => _compileFilter(nodes, opts);\nexport const compileFilterIdxs = (nodes, opts = OPTS) => _compileFilter(nodes, opts, true);\n\n// TODO:\n// insert optional chaining\n// support negative index to avoid handling .at(-1) fn call\n// hasKey?\n// typeof (string, boolean, number, function, object, array)\n// date ranges?\n// array intersect? (list in list)",null],"names":["d","EMPTY_ARRAY","__IVI_STRINGS__","_Object","Object","_Array","Array","_isArray","isArray","_Map","Map","_Int32Array","Int32Array","_queueMicrotask","queueMicrotask","nodeProto","Node","prototype","elementProto","Element","doc","document","HTM_TEMPLATE","createElement","HTM_TEMPLATE_CONTENT","content","_SVG_TEMPLATE","firstChild","nodeInsertBefore","insertBefore","nodeRemoveChild","removeChild","nodeCloneNode","cloneNode","elementSetAttribute","setAttribute","elementRemoveAttribute","removeAttribute","elementAddEventListener","addEventListener","elementRemoveEventListener","removeEventListener","getDescriptor","o","p","getOwnPropertyDescriptor","nodeGetFirstChild","get","nodeGetNextSibling","nodeSetTextContent","set","elementSetInnerHTML","elementSetClassName","htmlElementGetStyle","HTMLElement","svgElementGetStyle","SVGElement","RENDER_CONTEXT","seal","n","si","e","createSNode","f","v","c","s1","_flushDOMEffects","length","i","_updateTemplateProperties","currentElement","opCodes","data","state","prevProps","nextProps","svg","style","op","type","dataIndex","propsIndex","next","key","prev","call","nodeValue","setProperty","removeProperty","_assignTemplateSlots","currentNode","offset","endOffset","ctx","enterOffset","commentNode","remove","_mountList","parentState","flags","children","vNode","sChildren","sNode","_mount","_updateArray","parentSNode","updateFlags","_unmount","prevSChildren","nextSChildren","prevLength","nextLength","sChild","_update","_dirtyCheck","descriptor","p2","parentElement","tplData","p1","propsOpCodes","childOpCodes","rootDOMNode","childrenIndex","childOpCode","value","_updateList","props","descriptorP1","parentDOMElement","nextDOMNode","stateOpCodes","s","s2","renderFn","createTextNode","detach","unmountHooks","a","b","aKeys","k","bKeys","bVNodes","bLength","aLength","result","aEnd","bEnd","start","outer","sources","keyIndex","j","nodePosition","nextPosition","markLIS","node","lisValue","lo","hi","parent","index","indexLength","_h","t","innerHTML","_hE","_T","_t","component","getProps","useUnmount","hook","hooks","push","useEffect","areEqual","reset","pending","invalidate","LIST_DESCRIPTOR","List","entries","getKey","render","map","_dirtyCheckRoot","root","domSlot","createRoot","useState","ISO8601","BOOL_RE","COL_DELIMS","stripBOM","str","charCodeAt","slice","toJSON","JSON","stringify","onlyStrEsc","getValParseExpr","ci","col","parse","rv","parseExpr","repl","nanExpr","NaN","nullExpr","null","emptyExpr","empty","segsRe","genToTypedRow","cols","objs","deep","buf","tplObj","colIdx","paths","name","replace","path","shift","segs","test","matchAll","flatMap","m","seg","endChar","at","nextNode","every","forEach","parseVal","Function","csvStr","schema","skip","each","withEOF","_maxCols","row","rowDelim","colDelim","encl","colEncl","esc","escEncl","trim","indexOf","replEsc","numCols","_probe","rowDelimLen","colDelimLen","colEnclChar","escEnclChar","rowDelimChar","colDelimChar","out","pos","endPos","linePos","rowTpl","fill","lastColIdx","filledColIdx","pos2","takeToCommaOrEOL","RegExp","inCol","pos0","shouldRep","posTo","cNext","cPrev","replaceAll","lastIndex","exec","partial","cleanRHS","cleanLHS","chain","cleanPath","EMPTY_OBJ","OPTS","ops","compileFilter","nodes","opts","_compileFilter","useIdx","expr","stmts","compileExpr","lhs","rhs","negate","$ops","exprs","node2","join","min","max","l","r","haltEvent","preventDefault","stopPropagation","stopImmediatePropagation","onWinCap","fn","window","capture","offWinCap","cmp","Intl","Collator","numeric","sensitivity","compare","compileSorterTuples","dir","simple","sorts","sort","body","compileMatcherStringTuples","rules","nonEmpty","filter","CSVDropper","onDrop","item","dataTransfer","items","kind","file","getAsFile","endsWith","text","then","console","time","inferSchema","maxRows","header","headerFn","firstRows","rowRE","firstRowMatch","match","firstRowStr","find","delim","split","headerRows","colNames","keys","splice","colName","guessType","rows","findLast","T_BOOLEAN","boolTrue","c0","c1","isJSON","initParser","_toStr","_toArr","_toObj","_toDeep","_toObjS","streamState","streamParse","streamCb","prevUnparsed","accum","add","initRows","initCols","addRow","addCol","gen","accInit","accAppend","genConvertRow","convertRow","cb","_skip","halted","res","_toStrGen","_toArrGen","stringArrs","stringObjs","typedArrs","typedObjs","typedDeep","typedCols","stringCols","chunk","end","timeEnd","setData","onDragOver","__ivi_1._t","__ivi_tpl_1","__ivi_hoist_1","__ivi_tpl_3","Table","dom","setDom","el","table","filts","sortDir","sortPos","dataFilt","dataSort","onClickCol","idx","shiftKey","Math","reSort","reFilt","sortFn","scrollTop","onChangeFiltOp","onChangeFiltVal","val","rowHgt","viewRows","chunkLen","idx0","colWids","incrRoundDn","num","incr","floor","sync","rFull","getBoundingClientRect","rThead","querySelector","viewHgt","height","rTbody","tbody","colEl","querySelectorAll","width","setIdx0","force","idx1","resizeObserver","ResizeObserver","observe","unobserve","disconnect","onClicks","onChangeFiltOps","target","onChangeFiltVals","onDowns","button","fromX","clientX","fromWid","onMove","newWid","onClick","__ivi_tpl_2","Cell","Row","__ivi_hoist_2","totalHgt","padTop","padBtm","__ivi_tpl_7","__ivi_tpl_5","__ivi_tpl_6","App","getData"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}