{"version":3,"file":"bundle.min.js","sources":["../node_modules/ivi/dist/lib/core.js","../node_modules/uexpr/src/uExpr.mjs","../src/utils.ts","../src/Table.ts","../node_modules/udsv/dist/uDSV.mjs","../src/CSVDropper.ts","../src/main.ts","../node_modules/ivi/dist/lib/state.js"],"sourcesContent":["export const EMPTY_ARRAY = [];\n/**\n * Globally shared strings is automatically generated by optimizer.\n */\nconst __IVI_STRINGS__ = /*@__IVI_STRINGS__*/ [];\n// Store global variables in a local scope as const variables so that JIT\n// compiler could easily inline functions and eliminate checks in case global\n// variables are overriden.\nconst _Object = Object;\nconst _Array = Array;\nconst _isArray = _Array.isArray;\nconst _Map = Map;\nconst _Int32Array = Int32Array;\nconst _queueMicrotask = queueMicrotask;\nconst _requestAnimationFrame = requestAnimationFrame;\nconst _requestIdleCallback = requestIdleCallback;\nconst nodeProto = Node.prototype;\nconst elementProto = Element.prototype;\nconst doc = document;\n// Template containers are used to create static templates from HTML strings\n// via `innerHTML`.\nconst HTM_TEMPLATE = /**@__PURE__*/ doc.createElement(\"template\");\nconst HTM_TEMPLATE_CONTENT = HTM_TEMPLATE.content;\nconst _SVG_TEMPLATE = /**@__PURE__*/ doc.createElement(\"template\");\nconst SVG_TEMPLATE = /**@__PURE__*/ doc.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n_SVG_TEMPLATE.content.appendChild(SVG_TEMPLATE);\nconst SVG_TEMPLATE_CONTENT = _SVG_TEMPLATE.content.firstChild;\n// Store Node/Element methods to avoid going through a long prototype chain and\n// avoid megamorphic call-sites when accessing DOM nodes.\n/** `Node.prototype.insertBefore` */\nconst nodeInsertBefore = nodeProto.insertBefore;\n/** `Node.prototype.removeChild`. */\nconst nodeRemoveChild = nodeProto.removeChild;\n/** `Node.prototype.cloneNode`. */\nconst nodeCloneNode = nodeProto.cloneNode;\n/** `Element.prototype.setAttribute` */\nconst elementSetAttribute = elementProto.setAttribute;\n/** `Element.prototype.removeAttribute` */\nconst elementRemoveAttribute = elementProto.removeAttribute;\n/** `EventTarget.prototype.addEventListener` */\nconst elementAddEventListener = elementProto.addEventListener;\n/** `EventTarget.prototype.removeEventListener` */\nconst elementRemoveEventListener = elementProto.removeEventListener;\n/** `Object.getOwnPropertyDescriptor(o, p)` */\nconst getDescriptor = (o, p) => _Object.getOwnPropertyDescriptor(o, p);\n/** `get Node.prototype.firstChild` */\nconst nodeGetFirstChild = /*@__PURE__*/ getDescriptor(nodeProto, \"firstChild\").get;\n/** `get Node.prototype.nextSibling` */\nconst nodeGetNextSibling = /*@__PURE__*/ getDescriptor(nodeProto, \"nextSibling\").get;\n/** `set Node.prototype.textContent` */\nconst nodeSetTextContent = /*@__PURE__*/ getDescriptor(nodeProto, \"textContent\").set;\n/** `set Element.prototype.innerHTML` */\nconst elementSetInnerHTML = /*@__PURE__*/ getDescriptor(elementProto, \"innerHTML\").set;\n/** `set Element.prototype.className` */\nconst elementSetClassName = /*@__PURE__*/ getDescriptor(elementProto, \"className\").set;\n/** `get HTMLElement.prototype.style`. */\nconst htmlElementGetStyle = /*@__PURE__*/ getDescriptor(HTMLElement.prototype, \"style\").get;\n/** `get SVGElement.prototype.style` */\nconst svgElementGetStyle = /*@__PURE__*/ getDescriptor(SVGElement.prototype, \"style\").get;\n// When object is sealed and stored in a const variable, JIT compiler can\n// eliminate object map(shape) checks when accessing its properties.\n/**\n * Global Render Context.\n */\nexport const RENDER_CONTEXT = _Object.seal({\n    p: null,\n    n: null,\n    si: 0,\n    e: [],\n});\n/**\n * Creates a Stateful Node instance.\n *\n * @param v VNode.\n * @returns {@link SNode} instance.\n */\nexport const createSNode = (f, v, c, p, s1) => ({ f, v, c, p, s1 });\nexport const _flushDOMEffects = () => {\n    const e = RENDER_CONTEXT.e;\n    if (e.length > 0) {\n        RENDER_CONTEXT.e = [];\n        for (let i = 0; i < e.length; i++) {\n            e[i]();\n        }\n    }\n};\nconst _updateTemplateProperties = (currentElement, opCodes, data, state, prevProps, nextProps, svg) => {\n    let style;\n    for (let i = 0; i < opCodes.length; i++) {\n        const op = opCodes[i];\n        const type = op & 7 /* PropOpCode.TypeMask */;\n        const dataIndex = op >> 9 /* PropOpCode.DataShift */;\n        if (type === 0 /* PropOpCode.SetNode */) {\n            currentElement = state[dataIndex];\n            style = void 0;\n        }\n        else {\n            const propsIndex = (op >> 3 /* PropOpCode.InputShift */) & 63 /* PropOpCode.Mask6 */;\n            const next = nextProps[propsIndex];\n            if (type === 4 /* PropOpCode.DiffDOMProperty */) {\n                const key = data[dataIndex];\n                if (prevProps === null) {\n                    if (next !== void 0) {\n                        currentElement[key] = next;\n                    }\n                }\n                else if (currentElement[key] !== next) {\n                    currentElement[key] = next;\n                }\n            }\n            else {\n                let prev;\n                if (prevProps !== null) {\n                    prev = prevProps[propsIndex];\n                }\n                if (prev !== next) {\n                    if (type === 1 /* PropOpCode.Common */) {\n                        if (dataIndex === 0 /* CommonPropType.ClassName */) {\n                            if (next !== \"\" && next != null && next !== false) {\n                                elementSetClassName.call(currentElement, next);\n                            }\n                            else if (prev !== \"\" && prev != null && prev !== false) {\n                                elementSetClassName.call(currentElement, \"\");\n                            }\n                        }\n                        else if (dataIndex === 1 /* CommonPropType.TextContent */) {\n                            if (next !== \"\" && next != null && next !== false) {\n                                if (prev == null || prev === \"\" || prev === false) {\n                                    nodeSetTextContent.call(currentElement, next);\n                                }\n                                else {\n                                    nodeGetFirstChild.call(currentElement).nodeValue = next;\n                                }\n                            }\n                            else if (prev != null && prev !== \"\" && prev !== false) {\n                                nodeSetTextContent.call(currentElement, \"\");\n                            }\n                        }\n                        else { // CommonPropType.InnerHTML\n                            if (next !== \"\" && next != null && next !== false) {\n                                elementSetInnerHTML.call(currentElement, next);\n                            }\n                            else if (prev !== \"\" && prev != null && prev !== false) {\n                                nodeSetTextContent.call(currentElement, \"\");\n                            }\n                        }\n                    }\n                    else if (type === 7 /* PropOpCode.Directive */) {\n                        next(currentElement);\n                    }\n                    else {\n                        const key = data[dataIndex];\n                        if (type === 2 /* PropOpCode.Attribute */) {\n                            if (next !== false && next != null) {\n                                elementSetAttribute.call(currentElement, key, next);\n                            }\n                            else if (prev !== false && prev != null) {\n                                elementRemoveAttribute.call(currentElement, key);\n                            }\n                        }\n                        else if (type === 3 /* PropOpCode.Property */) {\n                            currentElement[key] = next;\n                        }\n                        else if (type === 5 /* PropOpCode.Style */) {\n                            if (next !== false && next != null) {\n                                if (style === void 0) {\n                                    style = (svg === false)\n                                        ? htmlElementGetStyle.call(currentElement)\n                                        : svgElementGetStyle.call(currentElement);\n                                }\n                                style.setProperty(key, next);\n                            }\n                            else if (prev !== false && prev != null) {\n                                if (style === void 0) {\n                                    style = (svg === false)\n                                        ? htmlElementGetStyle.call(currentElement)\n                                        : svgElementGetStyle.call(currentElement);\n                                }\n                                style.removeProperty(key);\n                            }\n                        }\n                        else { // PropOpCode.Event\n                            if (prev != null && prev !== false) {\n                                elementRemoveEventListener.call(currentElement, key, prev);\n                            }\n                            if (next != null && next !== false) {\n                                elementAddEventListener.call(currentElement, key, next);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n};\nconst _assignTemplateSlots = (currentNode, opCodes, offset, endOffset, state) => {\n    const ctx = RENDER_CONTEXT;\n    while (true) {\n        const op = opCodes[offset++];\n        if (op & 1 /* StateOpCode.Save */) {\n            state[++ctx.si] = currentNode;\n        }\n        if (op & 2 /* StateOpCode.EnterOrRemove */) {\n            const enterOffset = op >> 2 /* StateOpCode.OffsetShift */;\n            // Enter offset is used to disambiguate between enter and remove\n            // operations. Remove operations will always have a 0 enterOffset.\n            if (enterOffset) { // Enter\n                _assignTemplateSlots(nodeGetFirstChild.call(currentNode), opCodes, offset, offset += enterOffset, state);\n            }\n            else { // Remove\n                // Remove operation implies that current node is always a comment node\n                // followed by a text node.\n                const commentNode = currentNode;\n                state[++ctx.si] = currentNode = nodeGetNextSibling.call(currentNode);\n                commentNode.remove();\n            }\n        }\n        if (offset === endOffset) {\n            return;\n        }\n        currentNode = nodeGetNextSibling.call(currentNode);\n    }\n};\nconst _mountList = (parentState, flags, children, vNode) => {\n    let i = children.length;\n    const sChildren = _Array(i);\n    const sNode = createSNode(flags, vNode, sChildren, parentState, null);\n    while (i > 0) {\n        sChildren[--i] = _mount(sNode, children[i]);\n    }\n    return sNode;\n};\nconst _updateArray = (parentSNode, sNode, next, updateFlags) => {\n    if (!_isArray(next)) {\n        _unmount(sNode, true);\n        return _mount(parentSNode, next);\n    }\n    const prevSChildren = sNode.c;\n    let nextSChildren = prevSChildren;\n    let prevLength = prevSChildren.length;\n    let nextLength = next.length;\n    if (nextLength !== prevLength) {\n        sNode.c = nextSChildren = _Array(nextLength);\n        while (prevLength > nextLength) {\n            const sChild = prevSChildren[--prevLength];\n            if (sChild !== null) {\n                _unmount(sChild, true);\n            }\n        }\n        while (nextLength > prevLength) {\n            nextSChildren[--nextLength] = _mount(sNode, next[nextLength]);\n        }\n    }\n    while (nextLength > 0) {\n        nextSChildren[--nextLength] = _update(sNode, prevSChildren[nextLength], next[nextLength], updateFlags);\n    }\n    return sNode;\n};\n/**\n * Updates a Stateful Node with a new Stateless Node.\n *\n * @param parentSNode Parent Stateul Node.\n * @param sNode Stateful Node to update.\n * @param next New Stateless Node.\n * @param updateFlags Update flags (ForceUpdate and DisplaceNode).\n * @returns Stateful Node.\n */\nconst _update = (parentSNode, sNode, next, updateFlags) => {\n    if (sNode === null) {\n        return _mount(parentSNode, next);\n    }\n    if (next === false || next == null || next === \"\") {\n        _unmount(sNode, true);\n        return null;\n    }\n    // polymorphic call-site\n    const children = sNode.c;\n    const prev = sNode.v;\n    const state = sNode.s1;\n    const flags = sNode.f;\n    const type = flags & 127 /* Flags.TypeMask */;\n    sNode.f = type;\n    // Reassign to reduce memory consumption even if next value is strictly\n    // equal to the prev value.\n    sNode.v = next;\n    // Text and Array should be checked before Component, Template and List\n    // because their stateless nodes are represented with basic string and array\n    // types.\n    if (type === 16 /* Flags.Text */) {\n        const ctx = RENDER_CONTEXT;\n        if (typeof next !== \"object\") {\n            if (prev !== next) {\n                state.nodeValue = next;\n            }\n            if (updateFlags & 1024 /* Flags.DisplaceNode */) {\n                nodeInsertBefore.call(ctx.p, state, ctx.n);\n            }\n            ctx.n = state;\n            return sNode;\n        }\n        nodeRemoveChild.call(ctx.p, state);\n        return _mount(parentSNode, next);\n    }\n    if (prev === next) {\n        _dirtyCheck(sNode, updateFlags);\n        return sNode;\n    }\n    // Dirty flags should be cleared after dirty checking.\n    sNode.f = type;\n    if (type === 8 /* Flags.Array */) {\n        return _updateArray(parentSNode, sNode, next, updateFlags);\n    }\n    const descriptor = next.d;\n    const nextProps = next.p;\n    const prevProps = prev.p;\n    if (prev.d !== descriptor) {\n        _unmount(sNode, true);\n        return _mount(parentSNode, next);\n    }\n    if (type === 2 /* Flags.Component */) {\n        if (((flags | updateFlags) & (128 /* Flags.Dirty */ | 512 /* Flags.ForceUpdate */)) ||\n            (descriptor.p2 === void 0) ||\n            (descriptor.p2(prevProps, nextProps) !== true)) {\n            sNode.c = _update(sNode, children, state(nextProps), updateFlags);\n        }\n        else if (children !== null) {\n            _dirtyCheck(children, updateFlags);\n        }\n    }\n    else if (type === 1 /* Flags.Template */) {\n        const ctx = RENDER_CONTEXT;\n        const parentElement = ctx.p;\n        const tplData = descriptor.p1;\n        const flags = tplData.f;\n        const data = tplData.d;\n        const propsOpCodes = tplData.p;\n        const childOpCodes = tplData.c;\n        const rootDOMNode = state[0];\n        if (updateFlags & 1024 /* Flags.DisplaceNode */) {\n            updateFlags ^= 1024 /* Flags.DisplaceNode */;\n            nodeInsertBefore.call(parentElement, rootDOMNode, ctx.n);\n        }\n        _updateTemplateProperties(rootDOMNode, propsOpCodes, data, state, prevProps, nextProps, !!(flags & 4096 /* TemplateFlags.Svg */));\n        if (children !== null) {\n            ctx.p = rootDOMNode;\n            ctx.n = null;\n            let childrenIndex = 0;\n            for (let i = 0; i < childOpCodes.length; i++) {\n                const childOpCode = childOpCodes[i];\n                const type = childOpCode & 3 /* ChildOpCode.Type */;\n                const value = childOpCode >> 2 /* ChildOpCode.ValueShift */;\n                if (type === 0 /* ChildOpCode.Child */) {\n                    children[childrenIndex] =\n                        _update(sNode, children[childrenIndex++], nextProps[value], updateFlags);\n                }\n                else if (type === 1 /* ChildOpCode.SetNext */) {\n                    ctx.n = state[value];\n                }\n                else { // ChildOpCode.SetParent\n                    ctx.p = state[value];\n                    ctx.n = null;\n                }\n            }\n            ctx.p = parentElement;\n        }\n        ctx.n = rootDOMNode;\n    }\n    else if (type === 4 /* Flags.List */) {\n        _updateList(sNode, prevProps, nextProps, updateFlags);\n    }\n    else { // Context\n        if (prevProps.v !== nextProps.v) {\n            updateFlags |= 512 /* Flags.ForceUpdate */;\n        }\n        sNode.c = _update(sNode, children, nextProps.c, updateFlags);\n    }\n    return sNode;\n};\n/**\n * Mounts Stateless Node.\n *\n * @param parentSNode Parent Stateful Node.\n * @param v Stateless Node.\n * @returns Mounted Stateful Node.\n */\nconst _mount = (parentSNode, v) => {\n    if (v !== false && v != null) {\n        if (typeof v === \"object\") {\n            if (_isArray(v)) {\n                return _mountList(parentSNode, 8 /* Flags.Array */, v, v);\n            }\n            else {\n                const descriptor = v.d;\n                const props = v.p;\n                const descriptorP1 = descriptor.p1;\n                const type = descriptor.f & (1 /* Flags.Template */ | 2 /* Flags.Component */ | 4 /* Flags.List */);\n                if (type === 1 /* Flags.Template */) {\n                    const ctx = RENDER_CONTEXT;\n                    const parentDOMElement = ctx.p;\n                    const nextDOMNode = ctx.n;\n                    const tplData = descriptorP1;\n                    const data = tplData.d;\n                    const propsOpCodes = tplData.p;\n                    const stateOpCodes = tplData.s;\n                    const childOpCodes = tplData.c;\n                    const flags = tplData.f;\n                    const rootDOMNode = descriptor.p2();\n                    const state = _Array(flags & 63 /* TemplateFlags.Mask6 */);\n                    state[0] = rootDOMNode;\n                    if (stateOpCodes.length > 0) {\n                        ctx.si = 0;\n                        _assignTemplateSlots(nodeGetFirstChild.call(rootDOMNode), stateOpCodes, 0, stateOpCodes.length, state);\n                    }\n                    _updateTemplateProperties(rootDOMNode, propsOpCodes, data, state, null, props, !!(flags & 4096 /* TemplateFlags.Svg */));\n                    const sNode = createSNode(1 /* Flags.Template */, v, null, parentSNode, state);\n                    if (childOpCodes.length > 0) {\n                        const children = _Array((flags >> 6 /* TemplateFlags.ChildrenSizeShift */) & 63 /* TemplateFlags.Mask6 */);\n                        sNode.c = children;\n                        ctx.p = rootDOMNode;\n                        ctx.n = null;\n                        let childrenIndex = 0;\n                        for (let i = 0; i < childOpCodes.length; i++) {\n                            const childOpCode = childOpCodes[i];\n                            const type = childOpCode & 3 /* ChildOpCode.Type */;\n                            const value = childOpCode >> 2 /* ChildOpCode.ValueShift */;\n                            if (type === 0 /* ChildOpCode.Child */) {\n                                children[childrenIndex++] = _mount(sNode, props[value]);\n                            }\n                            else if (type === 1 /* ChildOpCode.SetNext */) {\n                                ctx.n = state[value];\n                            }\n                            else { // ChildOpCode.SetParent\n                                ctx.p = state[value];\n                                ctx.n = null;\n                            }\n                        }\n                        ctx.p = parentDOMElement;\n                    }\n                    ctx.n = rootDOMNode;\n                    nodeInsertBefore.call(parentDOMElement, rootDOMNode, nextDOMNode);\n                    return sNode;\n                }\n                else if (type === 2 /* Flags.Component */) {\n                    const sNode = {\n                        f: 2 /* Flags.Component */,\n                        v: v,\n                        c: null,\n                        p: parentSNode,\n                        s1: null,\n                        s2: null,\n                    };\n                    const renderFn = descriptorP1(sNode);\n                    sNode.c = _mount(sNode, renderFn(props));\n                    sNode.s1 = renderFn;\n                    return sNode;\n                }\n                else if (type === 4 /* Flags.List */) {\n                    return _mountList(parentSNode, 4 /* Flags.List */, props.v, v);\n                }\n                // Context\n                const sNode = createSNode(64 /* Flags.Context */, v, null, parentSNode, null);\n                sNode.c = _mount(sNode, props.c);\n                return sNode;\n            }\n        }\n        else if (v !== \"\") { // text\n            const ctx = RENDER_CONTEXT;\n            const next = ctx.n;\n            const e = doc.createTextNode(v);\n            ctx.n = e;\n            nodeInsertBefore.call(ctx.p, e, next);\n            return createSNode(16 /* Flags.Text */, v, null, parentSNode, e);\n        }\n    }\n    return null;\n};\n/**\n * Performs a Dirty Checking in a Stateful Node Subtree.\n *\n * @param sNode Stateful Node.\n * @param updateFlags Update flags (ForceUpdate and DisplaceNode).\n */\nconst _dirtyCheck = (sNode, updateFlags) => {\n    const ctx = RENDER_CONTEXT;\n    // polymorphic call-site\n    const state = sNode.s1;\n    const v = sNode.v;\n    const children = sNode.c;\n    const flags = sNode.f;\n    const type = flags & 127 /* Flags.TypeMask */;\n    sNode.f = type;\n    if (type === 1 /* Flags.Template */) {\n        const rootDOMNode = state[0];\n        if (updateFlags & 1024 /* Flags.DisplaceNode */) {\n            updateFlags ^= 1024 /* Flags.DisplaceNode */;\n            nodeInsertBefore.call(ctx.p, rootDOMNode, ctx.n);\n        }\n        if (flags & 256 /* Flags.DirtySubtree */) {\n            ctx.p = rootDOMNode;\n            ctx.n = null;\n            const parentDOMElement = ctx.p;\n            const childOpCodes = v.d.p1.c;\n            let childrenIndex = 0;\n            for (let i = 0; i < childOpCodes.length; i++) {\n                const op = childOpCodes[i];\n                const type = op & 3 /* ChildOpCode.Type */;\n                const value = op >> 2 /* ChildOpCode.ValueShift */;\n                if (type === 0 /* ChildOpCode.Child */) {\n                    const sChild = children[childrenIndex++];\n                    if (sChild !== null) {\n                        _dirtyCheck(sChild, updateFlags);\n                    }\n                }\n                else if (type === 1 /* ChildOpCode.SetNext */) {\n                    ctx.n = state[value];\n                }\n                else { // ChildOpCode.SetParent\n                    ctx.p = state[value];\n                    ctx.n = null;\n                }\n            }\n            ctx.p = parentDOMElement;\n        }\n        ctx.n = rootDOMNode;\n    }\n    else if (type === 16 /* Flags.Text */) {\n        if (updateFlags & 1024 /* Flags.DisplaceNode */) {\n            nodeInsertBefore.call(ctx.p, state, ctx.n);\n        }\n        ctx.n = state;\n    }\n    else if (type === 2 /* Flags.Component */) {\n        if ((flags | updateFlags) & (128 /* Flags.Dirty */ | 512 /* Flags.ForceUpdate */)) {\n            sNode.c = _update(sNode, children, state(v.p), updateFlags);\n        }\n        else if (children !== null) {\n            _dirtyCheck(children, updateFlags);\n        }\n    }\n    else if (type === 64 /* Flags.Context */) {\n        if (children !== null) {\n            _dirtyCheck(children, updateFlags);\n        }\n    }\n    else { // Array || List\n        let i = children.length;\n        while (--i >= 0) {\n            const sChild = children[i];\n            if (sChild !== null) {\n                _dirtyCheck(sChild, updateFlags);\n            }\n        }\n    }\n};\n/**\n * Unmounts Stateful Node.\n *\n * @param sNode Stateful Node.\n * @param detach Detach root DOM nodes from the DOM.\n */\nconst _unmount = (sNode, detach) => {\n    const flags = sNode.f; // polymorphic call-site\n    const sChildren = sNode.c;\n    if (detach === true && (flags & (1 /* Flags.Template */ | 16 /* Flags.Text */))) {\n        detach = false;\n        nodeRemoveChild.call(RENDER_CONTEXT.p, (flags & 1 /* Flags.Template */)\n            ? sNode.s1[0]\n            : sNode.s1);\n    }\n    if (flags & 2 /* Flags.Component */) {\n        const unmountHooks = sNode.s2;\n        if (unmountHooks !== null) {\n            if (typeof unmountHooks === \"function\") {\n                unmountHooks();\n            }\n            else {\n                for (let i = 0; i < unmountHooks.length; i++) {\n                    unmountHooks[i]();\n                }\n            }\n        }\n    }\n    if (sChildren !== null) {\n        if (_isArray(sChildren)) {\n            for (let i = 0; i < sChildren.length; i++) {\n                const sChild = sChildren[i];\n                if (sChild !== null) {\n                    _unmount(sChild, detach);\n                }\n            }\n        }\n        else {\n            _unmount(sChildren, detach);\n        }\n    }\n};\n/**\n * Update children list with track by key algorithm.\n *\n * High-level overview of the algorithm that is implemented in this function:\n *\n * This algorithm finds a minimum number of DOM operations. It works in\n * several steps:\n *\n * 1. Common prefix and suffix optimization.\n *\n * Look for nodes with identical keys by simultaneously iterating through nodes\n * in the old children list `A` and new children list `B` from both sides.\n *\n *     A: -> [a b c d] <-\n *     B: -> [a b d] <-\n *\n * Skip nodes \"a\" and \"b\" at the start, and node \"d\" at the end.\n *\n *     A: -> [c] <-\n *     B: -> [] <-\n *\n * 2. Zero length optimizations.\n *\n * Check if the size of one of the list is equal to zero. When length of the\n * old children list is zero, insert remaining nodes from the new list. When\n * length of the new children list is zero, remove remaining nodes from the old\n * list.\n *\n *     A: -> [a b c g] <-\n *     B: -> [a g] <-\n *\n * Skip nodes \"a\" and \"g\" (prefix and suffix optimization).\n *\n *     A: [b c]\n *     B: []\n *\n * Remove nodes \"b\" and \"c\".\n *\n * 3. Index and unmount removed nodes.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *     P: [. . . . .] // . == -1\n *\n * Create array `P` (`sources`) with the length of the new children list and\n * fills it with `NewNodeMark` values. This mark indicates that node at this\n * position should be mounted. Later we will assign node positions in the old\n * children list to this array.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *     P: [. . . . .] // . == -1\n *     I: {\n *       c: 0, // B[0] == c\n *       b: 1, // B[1] == b\n *       h: 2,\n *       f: 3,\n *       e: 4,\n *     }\n *     last = 0\n *\n * Create reverse index `I` that maps keys to node positions in the new\n * children list.\n *\n *     A: [b c d e f]\n *         ^\n *     B: [c b h f e]\n *     P: [. 0 . . .] // . == -1\n *     I: {\n *       c: 0,\n *       b: 1, <-\n *       h: 2,\n *       f: 3,\n *       e: 4,\n *     }\n *     last = 1\n *\n * Assign original positions of the nodes from the old children list to the\n * array `P`.\n *\n * Iterate through nodes in the old children list and gets their new positions\n * from the index `I`. Assign old node position to the array `P`. When index\n * `I` doesn't have a key for the old node, it means that it should be\n * unmounted.\n *\n * When we assigning positions to the array `P`, we also store position of the\n * last seen node in the new children list `pos`, if the last seen position is\n * greater than the current position of the node at the new list, then we are\n * switching `rearrangeNodes` flag to `true` (`pos === RearrangeNodes`).\n *\n *     A: [b c d e f]\n *           ^\n *     B: [c b h f e]\n *     P: [1 0 . . .] // . == -1\n *     I: {\n *       c: 0, <-\n *       b: 1,\n *       h: 2,\n *       f: 3,\n *       e: 4,\n *     }\n *     last = 1 // last > 0; rearrangeNodes = true\n *\n * The last position `1` is greater than the current position of the node at the\n * new list `0`, switch `rearrangeNodes` flag to `true`.\n *\n *     A: [b c d e f]\n *             ^\n *     B: [c b h f e]\n *     P: [1 0 . . .] // . == -1\n *     I: {\n *       c: 0,\n *       b: 1,\n *       h: 2,\n *       f: 3,\n *       e: 4,\n *     }\n *     rearrangeNodes = true\n *\n * Node with key \"d\" doesn't exist in the index `I`, unmounts node `d`.\n *\n *     A: [b c d e f]\n *               ^\n *     B: [c b h f e]\n *     P: [1 0 . . 3] // . == -1\n *     I: {\n *       c: 0,\n *       b: 1,\n *       h: 2,\n *       f: 3,\n *       e: 4, <-\n *     }\n *     rearrangeNodes = true\n *\n * Assign position `3` for `e` node.\n *\n *     A: [b c d e f]\n *                 ^\n *     B: [c b h f e]\n *     P: [1 0 . 4 3] // . == -1\n *     I: {\n *       c: 0,\n *       b: 1,\n *       h: 2,\n *       f: 3, <-\n *       e: 4,\n *     }\n *     rearrangeNodes = true\n *\n * Assign position `4` for 'f' node.\n *\n * 4. Find minimum number of moves when `rearrangeNodes` flag is on and mount\n *    new nodes.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *     P: [1 * . 4 *] // . == -1  * == -2\n *\n * When `rearrangeNodes` is on, mark all nodes in the array `P` that belong to\n * the [longest increasing subsequence](http://en.wikipedia.org/wiki/Longest_increasing_subsequence)\n * and move all nodes that doesn't belong to this subsequence.\n *\n * Iterate over the new children list and the `P` array simultaneously. When\n * value from `P` array is equal to `NewNodeMark`, mount a new node. When it\n * isn't equal to `LisMark`, move it to a new position.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *                 ^  // new_pos == 4\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *                 ^\n *\n * Node \"e\" has `LisMark` value in the array `P`, nothing changes.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *               ^    // new_pos == 3\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *               ^\n *\n * Node \"f\" has `4` value in the array `P`, move it before the next node \"e\".\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *             ^      // new_pos == 2\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *             ^\n *\n * Node \"h\" has `NewNodeMark` value in the array `P`, mount new node \"h\".\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *           ^        // new_pos == 1\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *           ^\n *\n * Node \"b\" has `LisMark` value in the array `P`, nothing changes.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *         ^          // new_pos == 0\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *\n * Node \"c\" has `1` value in the array `P`, move it before the next node \"b\".\n *\n * When `rearrangeNodes` flag is off, skip LIS algorithm and mount nodes that\n * have `NewNodeMark` value in the array `P`.\n *\n * NOTE: There are many variations of this algorithm that are used by many UI\n * libraries and many implementations are still using an old optimization\n * technique that were removed several years ago from this implementation. This\n * optimization were used to improve performance of simple moves/swaps. E.g.\n *\n *     A: -> [a b c] <-\n *     B: -> [c b a] <-\n *\n * Move \"a\" and \"c\" nodes to the other edge.\n *\n *     A: -> [b] <-\n *     B: -> [b] <-\n *\n * Skip node \"b\".\n *\n * This optimization were removed because it breaks invariant that insert and\n * remove operations shouldn't trigger a move operation. E.g.\n *\n *     A: -> [a b]\n *     B:    [c a] <-\n *\n * Move node \"a\" to the end.\n *\n *     A: [b]\n *     B: [c a]\n *\n * Remove node \"b\" and insert node \"c\".\n *\n * In this use case, this optimization performs one unnecessary operation.\n * Instead of removing node \"b\" and inserting node \"c\", it also moves node \"a\".\n *\n * @param sNode {@link SList} node.\n * @param a Previous {@link ListProps}.\n * @param b Next {@link ListProps}.\n * @param updateFlags Update flags.\n * @noinline\n * @__NOINLINE__\n */\nconst _updateList = (sNode, a, b, updateFlags) => {\n    const aKeys = a.k;\n    const bKeys = b.k;\n    const bVNodes = b.v;\n    let bLength = bKeys.length;\n    let aLength = aKeys.length;\n    const result = _Array(bLength);\n    if (bLength === 0) { // New children list is empty.\n        if (aLength > 0) { // Unmount nodes from the old children list.\n            _unmount(sNode, true);\n        }\n    }\n    else if (aLength === 0) { // Old children list is empty.\n        while (bLength > 0) { // Mount nodes from the new children list.\n            result[--bLength] = _mount(sNode, bVNodes[bLength]);\n        }\n    }\n    else {\n        const sChildren = sNode.c;\n        let aEnd = aLength - 1;\n        let bEnd = bLength - 1;\n        let start = 0;\n        // Step 1\n        outer: while (true) {\n            // Update nodes with the same key at the end.\n            while (aKeys[aEnd] === bKeys[bEnd]) {\n                result[bEnd] = _update(sNode, sChildren[aEnd--], bVNodes[bEnd], updateFlags);\n                if (start > --bEnd || start > aEnd) {\n                    break outer;\n                }\n            }\n            // Update nodes with the same key at the beginning.\n            while (aKeys[start] === bKeys[start] && ++start <= aEnd && start <= bEnd) {\n                // delayed update (all updates should be performed from right-to-left).\n            }\n            break;\n        }\n        // Step 2\n        if (start > aEnd) {\n            // All nodes from `a` are updated, insert the rest from `b`.\n            while (bEnd >= start) {\n                result[bEnd] = _mount(sNode, bVNodes[bEnd--]);\n            }\n        }\n        else if (start > bEnd) {\n            // All nodes from `b` are updated, remove the rest from `a`.\n            bLength = start;\n            do {\n                const sChild = sChildren[bLength++];\n                if (sChild !== null) {\n                    _unmount(sChild, true);\n                }\n            } while (bLength <= aEnd);\n        }\n        else { // Step 3\n            let bLength = bEnd - start + 1;\n            const sources = new _Int32Array(bLength); // Maps positions in the new children list to positions in the old list.\n            const keyIndex = new _Map(); // Maps keys to their positions in the new children list.\n            for (let i = 0; i < bLength; i++) {\n                // `NewNodeMark` value indicates that node doesn't exist in the old children list.\n                sources[i] = -1 /* MagicValues.NewNodeMark */;\n                const j = start + i;\n                keyIndex.set(bKeys[j], j);\n            }\n            // When `nodePosition === RearrangeNodes`, it means that one of the nodes is in the wrong position and we should\n            // rearrange nodes with LIS-based algorithm `markLIS()`.\n            let nodePosition = 0;\n            for (let i = start; i <= aEnd; i++) {\n                const sChild = sChildren[i];\n                const nextPosition = keyIndex.get(aKeys[i]);\n                if (nextPosition !== void 0) {\n                    nodePosition = (nodePosition < nextPosition)\n                        ? nextPosition\n                        : 1073741823 /* MagicValues.RearrangeNodes */;\n                    sources[nextPosition - start] = i;\n                    result[nextPosition] = sChild;\n                }\n                else if (sChild !== null) {\n                    _unmount(sChild, true);\n                }\n            }\n            // Step 4\n            // Mark LIS nodes only when this node weren't moved `moveNode === false` and we've detected that one of the\n            // children nodes were moved `pos === MagicValues.MovedChildren`.\n            if (!(updateFlags & 1024 /* Flags.DisplaceNode */) && nodePosition === 1073741823 /* MagicValues.RearrangeNodes */) {\n                markLIS(sources);\n            }\n            while (bLength-- > 0) {\n                bEnd = bLength + start;\n                const node = bVNodes[bEnd];\n                const lisValue = sources[bLength];\n                result[bEnd] = (lisValue === -1)\n                    ? _mount(sNode, node)\n                    : _update(sNode, result[bEnd], node, updateFlags |\n                        ((nodePosition === 1073741823 /* MagicValues.RearrangeNodes */ && lisValue !== -2 /* MagicValues.LISMark */)\n                            ? 1024 /* Flags.DisplaceNode */\n                            : 0));\n            }\n        }\n        // Delayed update for nodes from Step 1 (prefix only). Reconciliation algorithm always updates nodes from right to\n        // left.\n        while (start > 0) {\n            result[--start] = _update(sNode, sChildren[start], bVNodes[start], updateFlags);\n        }\n    }\n    sNode.c = result;\n};\n/**\n * Modified Longest Increased Subsequence algorithm.\n *\n * Mutates input array `a` and replaces all values that are part of LIS with -2 value.\n *\n * Constraints:\n * - Doesn't work with negative numbers. -1 values are ignored.\n * - Input array `a` should contain at least one value that is greater than -1.\n *\n * {@link http://en.wikipedia.org/wiki/Longest_increasing_subsequence}\n *\n * @example\n *\n *     const A = Int32Array.from([-1, 0, 2, 1]);\n *     markLIS(A);\n *     // A => [-1, -2, 2, -2]\n *\n * @param a Array of numbers.\n * @noinline\n * @__NOINLINE__\n */\nconst markLIS = (a) => {\n    const length = a.length;\n    const parent = new _Int32Array(length);\n    const index = new _Int32Array(length);\n    let indexLength = 0;\n    let i = 0;\n    let j;\n    let k;\n    let lo;\n    let hi;\n    // Skip -1 values at the start of the input array `a`.\n    for (; a[i] === -1 /* MagicValues.NewNodeMark */; i++) { /**/ }\n    index[0] = i++;\n    for (; i < length; i++) {\n        k = a[i];\n        if (k !== -1 /* MagicValues.NewNodeMark */) { // Ignore -1 values.\n            j = index[indexLength];\n            if (a[j] < k) {\n                parent[i] = j;\n                index[++indexLength] = i;\n            }\n            else {\n                lo = 0;\n                hi = indexLength;\n                while (lo < hi) {\n                    j = (lo + hi) >> 1;\n                    if (a[index[j]] < k) {\n                        lo = j + 1;\n                    }\n                    else {\n                        hi = j;\n                    }\n                }\n                if (k < a[index[lo]]) {\n                    if (lo > 0) {\n                        parent[i] = index[lo - 1];\n                    }\n                    index[lo] = i;\n                }\n            }\n        }\n    }\n    ;\n    // Mutate input array `a` and assign -2 value to all nodes that are part of LIS.\n    j = index[indexLength];\n    while (indexLength-- >= 0) {\n        a[j] = -2 /* MagicValues.LISMark */;\n        j = parent[j];\n    }\n};\n/**\n * Creates a HTML Template cloning factory.\n *\n * @__NO_SIDE_EFFECTS__\n */\nexport const _h = (t) => (() => {\n    if (typeof t === \"string\") {\n        HTM_TEMPLATE.innerHTML = t;\n        t = HTM_TEMPLATE_CONTENT.firstChild;\n    }\n    return nodeCloneNode.call(t, true);\n});\n/**\n * Creates a HTML Template factory.\n *\n * @__NO_SIDE_EFFECTS__\n */\nexport const _hN = (t) => (() => (HTM_TEMPLATE.innerHTML = t,\n    HTM_TEMPLATE_CONTENT.firstChild));\n/**\n * Creates a HTML Element factory.\n *\n * @__NO_SIDE_EFFECTS__\n */\nexport const _hE = (t) => (() => doc.createElement(t));\n/**\n * Creates a SVG Template cloning factory.\n */\nexport const _s = (t) => (() => {\n    if (typeof t === \"string\") {\n        SVG_TEMPLATE.innerHTML = t;\n        t = SVG_TEMPLATE_CONTENT.firstChild;\n    }\n    return nodeCloneNode.call(t, true);\n});\n/**\n * Creates a SVG Template factory.\n *\n * @__NO_SIDE_EFFECTS__\n */\nexport const _sN = (t) => (() => (SVG_TEMPLATE.innerHTML = t,\n    SVG_TEMPLATE_CONTENT.firstChild));\n/**\n * Creates a SVG Element factory.\n *\n * @__NO_SIDE_EFFECTS__\n */\nexport const _sE = (t) => (() => doc.createElementNS(\"http://www.w3.org/2000/svg\", t));\n/**\n * Creates a template descriptor with globally shared data.\n *\n * @__NO_SIDE_EFFECTS__\n */\nexport const _T = (p2, f, p, c, s, d = __IVI_STRINGS__) => ({\n    f: 1 /* Flags.Template */,\n    p1: { f, p, c, s, d },\n    p2,\n});\n/**\n * @__NO_SIDE_EFFECTS__\n */\nexport const _t = (d, p) => ({ d, p });\n/**\n * Creates a factory that produces component nodes.\n *\n * @typeparam P Property type.\n * @param factory Function that produces stateful render functions.\n * @param areEqyal Function that checks `props` for equality.\n * @returns Factory that produces component nodes.\n * @__NO_SIDE_EFFECTS__\n */\nexport const component = (p1, p2) => {\n    const d = { f: 2 /* Flags.Component */, p1, p2 };\n    return (p) => ({ d, p });\n};\n/**\n * Gets current component props.\n *\n * @typeparam P Property type.\n * @param component Component node.\n * @returns Current component props.\n */\nexport const getProps = (component) => (component.v.p);\n/**\n * Adds an unmount hook.\n *\n * @example\n *\n *     const Example = component((c) => {\n *       useUnmount(c, () => { console.log(\"unmounted\"); });\n *\n *       return () => null;\n *     });\n *\n * @param component Component instance.\n * @param hook Unmount hook.\n */\nexport const useUnmount = (component, hook) => {\n    const hooks = component.s2;\n    component.s2 = (hooks === null)\n        ? hook\n        : (typeof hooks === \"function\")\n            ? [hooks, hook]\n            : (hooks.push(hook), hooks);\n};\n/**\n * Creates a side effect hook.\n *\n * @example\n *\n *     const Example = component((c) => {\n *       const [count, setCount] = useState(c, 0);\n *       const timer = useEffect(c, ({ interval }) => {\n *         const tid = setInterval(() => { setCount(count() + 1); }, interval);\n *         return () => { clearInterval(tid); };\n *       }, shallowEq);\n *\n *       return (interval) => (\n *         timer({ interval }),\n *\n *         html`<span>${count()}</span>`\n *       );\n *     });\n *\n * @typeparam T Hook props type.\n * @param component Component instance.\n * @param hook Side effect function.\n * @param areEqual Function that checks if input value hasn't changed.\n * @returns Side effect hook.\n */\nexport const useEffect = (component, hook, areEqual) => {\n    // var usage is intentional, see `docs/internals/perf.md` for an explanation.\n    var reset;\n    var prev;\n    var pending;\n    return (next) => {\n        if (pending !== true && (areEqual === void 0 ||\n            prev === void 0 ||\n            areEqual(prev, next) === false)) {\n            if (pending === void 0) {\n                useUnmount(component, () => {\n                    pending = false;\n                    if (reset !== void 0) {\n                        reset();\n                    }\n                });\n            }\n            pending = true;\n            RENDER_CONTEXT.e.push(() => {\n                if (pending === true) {\n                    pending = false;\n                    if (reset !== void 0) {\n                        reset();\n                    }\n                    reset = hook(next);\n                }\n            });\n        }\n        prev = next;\n    };\n};\nlet _layoutEffects = [];\nlet _idleEffects = [];\nconst _flushLayoutEffects = () => {\n    while (_layoutEffects.length > 0) {\n        const e = _layoutEffects;\n        _layoutEffects = [];\n        for (let i = 0; i < e.length; i++) {\n            e[i]();\n        }\n    }\n};\nconst _flushIdleEffects = () => {\n    while (_idleEffects.length > 0) {\n        const e = _idleEffects;\n        _idleEffects = [];\n        for (let i = 0; i < e.length; i++) {\n            e[i]();\n        }\n    }\n};\nexport const useLayoutEffect = (component, hook, areEqual) => {\n    // var usage is intentional, see `docs/internals/perf.md` for an explanation.\n    var reset;\n    var prev;\n    var pending;\n    return (next) => {\n        if (pending !== true && (areEqual === void 0 ||\n            prev === void 0 ||\n            areEqual(prev, next) === false)) {\n            if (pending === void 0) {\n                useUnmount(component, () => {\n                    pending = false;\n                    if (reset !== void 0) {\n                        reset();\n                    }\n                });\n            }\n            pending = true;\n            const queue = _layoutEffects;\n            if (queue.length === 0) {\n                _requestAnimationFrame(_flushLayoutEffects);\n            }\n            queue.push(() => {\n                if (pending === true) {\n                    pending = false;\n                    if (reset !== void 0) {\n                        reset();\n                    }\n                    reset = hook(next);\n                }\n            });\n        }\n        prev = next;\n    };\n};\nexport const useIdleEffect = (component, hook, areEqual) => {\n    // var usage is intentional, see `docs/internals/perf.md` for an explanation.\n    var reset;\n    var prev;\n    var pending;\n    return (next) => {\n        if (pending !== true && (areEqual === void 0 ||\n            prev === void 0 ||\n            areEqual(prev, next) === false)) {\n            if (pending === void 0) {\n                useUnmount(component, () => {\n                    pending = false;\n                    if (reset !== void 0) {\n                        reset();\n                    }\n                });\n            }\n            pending = true;\n            const queue = _idleEffects;\n            if (queue.length === 0) {\n                _requestIdleCallback(_flushIdleEffects);\n            }\n            queue.push(() => {\n                if (pending === true) {\n                    pending = false;\n                    if (reset !== void 0) {\n                        reset();\n                    }\n                    reset = hook(next);\n                }\n            });\n        }\n        prev = next;\n    };\n};\n/**\n * Invalidates a component.\n *\n * @param c Component instance.\n */\nexport const invalidate = (c) => {\n    if (!(c.f & 128 /* Flags.Dirty */)) {\n        c.f |= 128 /* Flags.Dirty */;\n        let prev = c;\n        let parent = c.p;\n        while (parent !== null) {\n            // Polymorphic call-sites\n            if (parent.f & 256 /* Flags.DirtySubtree */) {\n                return;\n            }\n            prev = parent;\n            parent.f |= 256 /* Flags.DirtySubtree */;\n            parent = parent.p;\n        }\n        prev.v.d.p1(prev, prev.s1);\n    }\n};\n/**\n * VDescriptor for List nodes.\n */\nexport const LIST_DESCRIPTOR = {\n    f: 4 /* Flags.List */,\n    p1: null,\n    p2: null,\n};\n/**\n * Creates a dynamic list.\n *\n * @typeparam E Entry type.\n * @typeparam K Key type.\n * @param entries Entries.\n * @param getKey Get key from entry function.\n * @param render Render entry function.\n * @returns Dynamic list.\n * @__NO_SIDE_EFFECTS__\n */\nexport const List = (entries, getKey, render) => ({\n    d: LIST_DESCRIPTOR,\n    p: {\n        k: entries.map(getKey),\n        v: entries.map(render),\n    },\n});\n/**\n * Performs dirty checking in a root subtree.\n *\n * When `forceUpdate` option is enabled, all components in a root subtree will\n * be updated.\n *\n * @param root Root Node.\n * @param forceUpdate Force update components.\n */\nexport const dirtyCheck = (root, forceUpdate) => {\n    _dirtyCheckRoot(root, forceUpdate === true\n        ? 512 /* Flags.ForceUpdate */\n        : 0);\n};\n/**\n * Performs a Dirty Checking in a root subtree.\n *\n * @param root Stateful Root Node.\n * @param updateFlags Update flags (ForceUpdate and DisplaceNode).\n */\nconst _dirtyCheckRoot = (root, updateFlags) => {\n    while ((updateFlags | root.f) & (256 /* Flags.DirtySubtree */ | 512 /* Flags.ForceUpdate */)) {\n        const ctx = RENDER_CONTEXT;\n        const { p, n } = ctx;\n        root.f = 32 /* Flags.Root */;\n        if (root.c !== null) {\n            const domSlot = root.v.p;\n            RENDER_CONTEXT.p = domSlot.p;\n            RENDER_CONTEXT.n = domSlot.n;\n            _dirtyCheck(root.c, updateFlags);\n            updateFlags = 0;\n            _flushDOMEffects();\n        }\n        ctx.p = p;\n        ctx.n = n;\n    }\n};\n/**\n * Updates a root subtree.\n *\n * @param root Stateful Root Node.\n * @param next New Stateless Node.\n * @param updateFlags Update flags (ForceUpdate and DisplaceNode).\n */\nconst _updateRoot = (root, next, updateFlags) => {\n    const ctx = RENDER_CONTEXT;\n    const { p, n } = ctx;\n    const domSlot = root.v.p;\n    ctx.p = domSlot.p;\n    ctx.n = domSlot.n;\n    root.f = 32 /* Flags.Root */;\n    root.c = _update(root, root.c, next, updateFlags);\n    _flushDOMEffects();\n    ctx.p = p;\n    ctx.n = n;\n    _dirtyCheckRoot(root, 0);\n};\n/**\n * Unmounts a root subtree.\n *\n * When `detach` option is enabled, root DOM nodes will be detached from the\n * DOM.\n *\n * @param root Root Node.\n * @param detach Detach root DOM nodes from the DOM.\n */\nexport const unmount = (root, detach) => {\n    if (root.c !== null) {\n        const ctx = RENDER_CONTEXT;\n        const { p, n } = ctx;\n        ctx.p = root.v.p.p;\n        root.f = 32 /* Flags.Root */;\n        _unmount(root.c, detach);\n        ctx.p = p;\n        ctx.n = n;\n    }\n};\n/**\n * Defines a root node with a custom invalidation hook.\n *\n * @param onInvalidate Invalidated Hook.\n * @returns Root Node factory.\n * @__NO_SIDE_EFFECTS__\n */\nexport const defineRoot = (p1) => {\n    var d = { f: 32 /* Flags.Root */, p1, p2: null };\n    return (p, n = null, s) => createSNode(32 /* Flags.Root */, \n    // VNode object.\n    {\n        // Root Descriptor.\n        d,\n        // VNode props object contains the location in the DOM tree where subtree\n        // should be rendered.\n        p: {\n            // Parent DOM Element.\n            p,\n            // Next DOM Node.\n            n,\n        },\n    }, \n    // Children.\n    null, \n    // Parent SNode.\n    null, \n    // Root state.\n    s);\n};\n/**\n * Creates a root node that uses microtask queue for scheduling updates.\n *\n * @param parentElement Parent DOM Element.\n * @param nextNode Next DOM Node.\n * @returns Root Node.\n */\nexport const createRoot = /*@__PURE__*/ defineRoot(\n// OnRootInvalidated hook\n(root) => {\n    // Schedules a microtask for dirty checking.\n    _queueMicrotask(() => {\n        _dirtyCheckRoot(root, 0);\n    });\n});\n/**\n * Updates a root subtree.\n *\n * When `forceUpdate` option is enabled, all components in a root subtree will\n * be updated.\n *\n * @param root Root Node.\n * @param v Stateless View Node.\n * @param forceUpdate Force update components.\n */\nexport const update = (root, v, forceUpdate) => {\n    _updateRoot(root, v, forceUpdate === true\n        ? 512 /* Flags.ForceUpdate */\n        : 0);\n};\n/**\n * Context.\n *\n * @returns Context getter and context provider.\n * @__NO_SIDE_EFFECTS__\n */\nexport const context = () => {\n    const d = { f: 64 /* Flags.Context */, p1: null, p2: null };\n    return [\n        (c) => _getContextValue(c, d),\n        (v, c) => ({ d, p: { v, c } }),\n    ];\n};\nconst _getContextValue = (c, d) => {\n    let node = c.p;\n    while (node !== null) {\n        if (node.f & 64 /* Flags.Context */ && node.v.d === d) {\n            return node.v.p.v;\n        }\n        node = node.p;\n    }\n};\n//# sourceMappingURL=core.js.map","const cleanRHS = v => JSON.stringify(v);\nconst cleanLHS = (path, chain = false) => {\n  if (path == null || path == '' || path == '$' || path == '$i')\n    return path;\n\n  let cleanPath = '';\n\n  // guard against access outside of scope\n  if (path[0] == '.' || path[0] == '[') {\n    // remove baddies\n    cleanPath = path.replace(/[^$\\w.?\\[\\]-]/ig, '');\n\n    // add optional chaining\n    if (chain) {\n      cleanPath = cleanPath\n        .replace(/\\.\\??/ig, '.?')\n        .replace(/(?:\\.\\?)?\\[/ig, '.?[');\n    }\n  }\n\n  return '$' + cleanPath;\n}\n\nconst EMPTY_ARR = [];\nconst EMPTY_OBJ = {};\n\nlet OPTS = { chain: false, ops: EMPTY_OBJ };\n\nexport function compileExpr(node, opts = OPTS, stmts = []) {\n  let op = node[0];\n  let lhs = node[1];\n  let rhs = node[2];\n\n  let expr = '';\n\n  let negate = op[0] == '!' && op != '!=' && op != '!==' && op != '!!' && op != '!';\n\n  op = negate ? op.slice(1) : op;\n\n  let $ops = opts.ops ?? EMPTY_OBJ;\n\n  if (typeof $ops[op] == 'function' && /^\\w+$/.test(op)) {\n    stmts.push(`let $args = ${JSON.stringify(lhs ?? null)};`);\n    expr = `$ops.${op}($, $i, $args)`;\n  }\n  else {\n    let path = op != '&&' && op != '||' ? cleanLHS(lhs, opts.chain) : '';\n\n    switch (op) {\n      case '&&':\n      case '||':\n        let exprs = node.slice(1).map(node2 => compileExpr(node2, opts, stmts));\n        expr = exprs.length > 1 ? `(${exprs.map(o => o.expr).join(` ${op} `)})` : exprs[0].expr;\n        break;\n\n      case 'truthy':\n      case '!!':\n        expr = `Boolean(${path})`;\n        break;\n      case 'falsy':\n      case '!':\n        expr = `!Boolean(${path})`;\n        break;\n\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n      case '>=':\n      case '<=':\n      case '<':\n      case '>':\n        expr = `${path} ${op} ${cleanRHS(rhs)}`;\n        break;\n\n      case 'some':\n      case 'every':\n        expr = `${path}.${op}(($, $i) => ${compileExpr(rhs, opts, stmts).expr})`;\n        break;\n\n      case ',':\n      case 'in':\n        expr = `$${stmts.length}.has(${path})`;\n        stmts.push(`let $${stmts.length} = new Set(${cleanRHS(rhs)});`);\n        break;\n\n      case '-':\n      case '[]':\n      case '()':\n      case '[)':\n      case '(]':\n        if (!Array.isArray(rhs)) break;\n\n        let [min, max] = rhs;\n        let [l, r] = op;\n        let lop = l == '[' || l == '-' ? '>=' : '>';\n        let rop = r == ']' || r == null ? '<=' : '<';\n        expr = `${path} ${lop} ${cleanRHS(min)} && ${path} ${rop} ${cleanRHS(max)}`;\n        break;\n\n      case 'startsWith':\n      case '^':\n        expr = `${path}.startsWith(${cleanRHS(rhs)})`;\n        break;\n\n      case 'endsWith':\n      case '$':\n        expr = `${path}.endsWith(${cleanRHS(rhs)})`;\n        break;\n\n      case 'includes':\n      case '*':\n        expr = `${path}.includes(${cleanRHS(rhs)})`;\n        break;\n\n      case 'regexp':\n      case 'regexpi':\n      case '/':\n      case '/i':\n        let flags = op.at(-1) == 'i' ? 'i' : '';\n        expr = `$${stmts.length}.test(${path})`;\n        stmts.push(`let $${stmts.length} = new RegExp(${cleanRHS(rhs)}, \"${flags}\");`);\n        break;\n\n      case 'isInteger':\n      case 'isFinite':\n      case 'isNaN':\n        expr = `Number.${op}(${path})`;\n        break;\n\n      case 'isArray':\n        expr = `Array.isArray(${path})`;\n        break;\n    }\n  }\n\n  expr = negate ? `!(${expr})` : expr;\n\n  return {\n    stmts,\n    expr\n  };\n}\n\nexport function compileMatcher(nodes, opts = OPTS) {\n  let { expr, stmts } = compileExpr(nodes, opts);\n\n  return new Function('$ops', `\n    ${stmts.join('\\n')};\n    return ($, $i = 0) => ${expr};\n  `)(opts.ops ?? EMPTY_OBJ);\n}\n\n/*\n// these are for loop exits\ncase 'all'\ncase 'first': // early break after count\ncase 'last':  // backwards early break\n  lhs = node[1]; // howMany\n  rhs = node[2];\ncase 'only':  // early return nothing if count > 1\n*/\n\nfunction _compileFilter(nodes, opts = OPTS, useIdx = false) {\n  let { expr, stmts } = compileExpr(nodes, opts);\n\n  return new Function('$ops', `\n    ${stmts.join('\\n')}\n    return arr => {\n      let out = [];\n      for (let $i = 0; $i < arr.length; $i++) {\n        let $ = arr[$i];\n        ${expr} && out.push(${useIdx ? '$i' : '$'});\n      }\n      return out;\n    };\n  `)(opts.ops ?? EMPTY_OBJ);\n}\n\n// objs struct should be like {\"prop\": [1,2,3,4], \"other\": ['a','b','c']}\nexport function compileExprCols(nodes, names = EMPTY_ARR, opts = OPTS) {\n  let { expr, stmts } = compileExpr(nodes, opts);\n\n  if (names.length > 0) {\n    names.forEach((name, i) => {\n      if (!/[^\\w.]/.test(name)) {\n        expr = expr.replaceAll(name, `[${i}][$i]`);\n      }\n    });\n  }\n\n  return { expr, stmts };\n}\n\nexport function compileMatcherCols(nodes, names, opts = OPTS) {\n  let { expr, stmts } = compileExprCols(nodes, names, opts);\n\n  return new Function('$ops', `\n    ${stmts.join('\\n')};\n    return ($, $i = 0) => ${expr};\n  `)(opts.ops ?? EMPTY_OBJ);\n}\n\nconst filterColsIdxsBody = expr => `\n      let len = cols[0].length;\n\n      let $ = cols;\n      let idxs = [];\n\n      for (let $i = 0; $i < len; $i++) {\n        ${expr} && idxs.push($i);\n      }\n`;\n\nexport function compileFilterColsIdxs(nodes, names, opts = OPTS) {\n  let { expr, stmts } = compileExprCols(nodes, names, opts);\n\n  return new Function('$ops', `\n    ${stmts.join('\\n')}\n    return cols => {\n      ${filterColsIdxsBody(expr)}\n      return idxs;\n    };\n  `)(opts.ops ?? EMPTY_OBJ);\n}\n\nexport function compileFilterCols(nodes, names, opts = OPTS) {\n  let { expr, stmts } = compileExprCols(nodes, names, opts);\n\n  return new Function('$ops', `\n    ${stmts.join('\\n')}\n    return cols => {\n      ${filterColsIdxsBody(expr)}\n\n      return cols.map(col => {\n        let fcol = [];\n\n        for (let i = 0; i < idxs.length; i++) {\n          fcol.push(col[idxs[i]]);\n        }\n\n        return fcol;\n      });\n    };\n  `)(opts.ops ?? EMPTY_OBJ);\n}\n\nexport const compileFilter = (nodes, opts = OPTS) => _compileFilter(nodes, opts);\nexport const compileFilterIdxs = (nodes, opts = OPTS) => _compileFilter(nodes, opts, true);\n\n// TODO:\n// insert optional chaining\n// support negative index to avoid handling .at(-1) fn call\n// hasKey?\n// typeof (string, boolean, number, function, object, array)\n// date ranges?\n// array intersect? (list in list)",null,null,"/**\n* Copyright (c) 2025, Leon Sorokin\n* All rights reserved. (MIT Licensed)\n*\n* uDSV.js\n* A small, fast CSV parser\n* https://github.com/leeoniya/uDSV (v0.7.2)\n*/\n\nconst comma = ',';\nconst quote = '\"';\nconst tab   = '\\t';\nconst pipe  = '|';\nconst semi  = ';';\n\nconst ISO8601 = /^\\d{4}-\\d{2}-\\d{2}(?:T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d{3,})?(?:Z|[-+]\\d{2}:?\\d{2}))?$/;\nconst BOOL_RE = /^(?:t(?:rue)?|f(?:alse)?|y(?:es)?|n(?:o)?|0|1)$/i;\n\nconst COL_DELIMS = [tab, pipe, semi, comma];\n\nfunction stripBOM(str) {\n\treturn str.charCodeAt(0) === 0xFEFF ? str.slice(1) : str;\n}\n\nfunction boolTrue(v) {\n\tlet [c0, c1 = ''] = v;\n\n\treturn (\n\t\tc0 == '1' || c0 == '0' ? '1' :\n\n\t\tc0 == 't' || c0 == 'f' ? (c1 == '' ? 't' : 'true') :\n\t\tc0 == 'T' || c0 == 'F' ? (c1 == '' ? 'T' : c1 == 'R' || c1 === 'A' ? 'TRUE' : 'True') :\n\n\t\tc0 == 'y' || c0 == 'n' ? (c1 == '' ? 'y' : 'yes') :\n\t\tc0 == 'Y' || c0 == 'N' ? (c1 == '' ? 'Y' : c1 == 'E' || c1 === 'O' ? 'YES'  : 'Yes')  :\n\n\t\t''\n\t);\n}\n\nfunction isJSON(v) {\n\tif (v[0] === '[' || v[0] === '{') {\n\t\ttry {\n\t\t\tJSON.parse(v);\n\t\t\treturn true;\n\t\t} catch {}\n\t}\n\n\treturn false;\n}\n\nconst T_STRING  = 's';\nconst T_DATE    = 'd';\nconst T_TIME    = 't';\nconst T_NUMBER  = 'n';\nconst T_JSON    = 'j';\nconst T_BOOLEAN = 'b';\n\nfunction guessType(ci, rows) {\n\t// row with a value to analyze\n\tlet row = rows.findLast(r =>\n\t\tr[ci] !== ''     &&\n\t\tr[ci] !== 'null' &&\n\t\tr[ci] !== 'NULL' &&\n\t\tr[ci] !== 'NaN'\n\t);\n\n\tlet t = T_STRING;\n\n\tif (row != null) {\n\t\tlet v = row[ci];\n\n\t\tt = (\n\t\t\tISO8601.test(v) ? T_DATE                        :\n\t\t\t+v === +v       ? T_NUMBER                      :\n\t\t\tBOOL_RE.test(v) ? T_BOOLEAN + ':' + boolTrue(v) :\n\t\t\tisJSON(v)       ? T_JSON                        :\n\t\t\tt\n\t\t);\n\t}\n\n\treturn t;\n}\n\nconst toJSON = JSON.stringify;\nconst onlyStrEsc = v => typeof v === 'string' ? toJSON(v) : v;\n\nfunction getValParseExpr(ci, col) {\n\tlet { type, parse } = col;\n\n\tlet rv = `r[${ci}]`;\n\n\tlet parseExpr =\n\t    parse   !=  null      ? `c[${ci}].parse(${rv})`                             :\n\t\ttype    === T_DATE    ? `new Date(${rv})`                                   :\n\t\ttype    === T_TIME    ? `Date.parse(${rv})`                                 :\n\t\ttype    === T_JSON    ? `JSON.parse(${rv})`                                 :\n\t\ttype    === T_NUMBER  ? `+${rv}`                                            :\n\t\ttype[0] === T_BOOLEAN ? `${rv} === ${toJSON(type.slice(2))} ? true : false` :\n\t\trv;\n\n\tlet { repl } = col;\n\n\tlet nanExpr   = repl.NaN   !== void 0 && type === T_NUMBER ? `${rv} === 'NaN' ? ${onlyStrEsc(repl.NaN)} : `                       : '';\n\tlet nullExpr  = repl.null  !== void 0                      ? `${rv} === 'null' || ${rv} === 'NULL' ? ${onlyStrEsc(repl.null)} : ` : '';\n\tlet emptyExpr = repl.empty !== void 0                      ? `${rv} === '' ? ${onlyStrEsc(repl.empty)} : `                        : '';\n\n\treturn `${emptyExpr} ${nullExpr} ${nanExpr} ${parseExpr}`;\n}\n\nconst segsRe = /\\w+(?:\\[|\\]?[\\.\\[]?|$)/gm;\n\nfunction genToTypedRow(cols, objs = false, deep = false) {\n\tlet buf = '';\n\n\tif (objs && deep) {\n\t\tlet tplObj = {};\n\t\tlet colIdx = 0;\n\n\t\tlet paths = cols.map(c => c.name.replace(/\\.(\\d+)\\.?/gi, '[$1]'));\n\n\t\tdo {\n\t\t\tlet path = paths.shift();\n\n\t\t\tlet segs = /\\s/.test(path) ? [path] : [...path.matchAll(segsRe)].flatMap(m => m.map(m => m.replace(']', '')));\n\n\t\t\tlet node = tplObj;\n\t\t\tdo {\n\t\t\t\tlet seg = segs.shift();\n\n\t\t\t\tlet key = seg;\n\t\t\t\tlet endChar = seg.at(-1);\n\t\t\t\tlet hasKids = endChar == '.' || endChar == '[';\n\n\t\t\t\tif (hasKids) {\n\t\t\t\t\tkey = seg.slice(0, -1);\n\t\t\t\t\tlet nextNode = node[key] ?? (endChar == '.' ? {} : []);\n\t\t\t\t\tnode = node[key] = nextNode;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tnode[key] = `${colIdx}`;\n\t\t\t} while (segs.length > 0);\n\n\t\t\tcolIdx++;\n\t\t} while (paths.length > 0);\n\n\t\tbuf = toJSON(tplObj).replace(/\"(\\d+)\"/g, (m, ci) => getValParseExpr(+ci, cols[+ci]));\n\t}\n\telse {\n\t\tif (!objs && cols.every(c => c.type === T_STRING))\n\t\t\tbuf = 'r';\n\t\telse {\n\t\t\tbuf = objs ? '{' : '[';\n\n\t\t\tcols.forEach((col, ci) => {\n\t\t\t\tbuf += objs ? `${toJSON(col.name)}:` : '';\n\t\t\t\tlet parseVal = getValParseExpr(ci, col);\n\t\t\t\tbuf += `${parseVal},`;\n\t\t\t});\n\n\t\t\tbuf += objs ? '}' : ']';\n\t\t}\n\t}\n\n\treturn new Function('c', `return r => (${buf});`)(cols);\n}\n\n// https://www.loc.gov/preservation/digital/formats/fdd/fdd000323.shtml\nfunction inferSchema(csvStr, opts, maxRows) {\n\tlet {\n\t\theader: headerFn,\n\t\tcol:    colDelim,\n\t\trow:    rowDelim,\n\t\tencl:   colEncl,\n\t\tesc:    escEncl,\n\t//\tomit,  // #comments and empty lines (ignore:), needs callback for empty and comments?\n\t\ttrim  = false,\n\t} = opts ?? {};\n\n\t// by default, grab first row, and skip it\n\theaderFn ??= firstRows => [firstRows[0]];\n\n\tmaxRows ??= 10;\n\n\tcsvStr = stripBOM(csvStr);\n\n\t// will fail if header contains line breaks in quoted value\n\t// will fail if single line without line breaks\n\tconst rowRE         = new RegExp(`(.*)(${rowDelim ?? '\\r\\n|\\r|\\n'})`);\n\tconst firstRowMatch = csvStr.match(rowRE);\n\tconst firstRowStr   = firstRowMatch[1];\n\n\trowDelim ??= firstRowMatch[2];\n\tcolDelim ??= COL_DELIMS.find(delim => firstRowStr.indexOf(delim) > -1) ?? comma;\n\n\tconst schema = {\n\t\tskip: 1, // how many header rows to skip\n\t\tcol:  colDelim,\n\t\trow:  rowDelim,\n\t\tencl: colEncl,\n\t\tesc:  escEncl,\n\t\ttrim: trim,\n\t\tcols: [],\n\t};\n\n\tconst _maxCols = firstRowStr.split(colDelim).length;\n\n\tconst firstRows = [];\n\tparse(csvStr, schema, 0, row => {\n\t\tfirstRows.push(row);\n\t\treturn firstRows.length < maxRows;\n\t}, true, _maxCols);\n\n\tlet headerRows = headerFn(firstRows) ?? [];\n\n\tlet skip = schema.skip = headerRows.length;\n\n\t// first non-null row\n\tlet colNames = headerRows.find(row => row != null) ?? [...Array(firstRows[0].length).keys()];\n\n\tfirstRows.splice(0, skip);\n\n\tcolNames.forEach((colName, colIdx) => {\n\t\tlet type = guessType(colIdx, firstRows);\n\n\t\tlet col = {\n\t\t\tname: colName,\n\t\t\ttype,\n\t\t\t// this could be type-dependant (e.g. {empty: 0, null: 0, NaN: NaN} for numbers)\n\t\t\trepl: {\n\t\t\t\tempty: null,\n\t\t\t\tNaN: void 0,\n\t\t\t\tnull: void 0,\n\t\t\t},\n\t\t};\n\n\t\tschema.cols.push(col);\n\t});\n\n\treturn schema;\n}\n\nfunction initParser(schema) {\n\tlet { skip, cols } = schema;\n\n\tlet _toStr = null;\n\tlet _toArr = null;\n\tlet _toObj = null;\n\tlet _toDeep = null;\n\tlet _toObjS = null;\n\n\tlet streamState = 0;\n\tlet streamParse = null;\n\tlet streamCb = null;\n\tlet prevUnparsed = '';\n\n\tlet buf = null;\n\n\tfunction reset() {\n\t\tstreamState = 0;\n\t\tprevUnparsed = '';\n\t\tstreamParse = streamCb = buf = null;\n\t}\n\n\tlet accum    = (row, buf, add) => {\n\t\tadd(buf, row);\n\t\treturn true;\n\t};\n\tlet initRows = () => [];\n\tlet initCols = () => cols.map(c => []);\n\tlet addRow   = (buf, row) => { buf.push(row); };\n\tlet addCol   = (buf, row) => {\n\t\tfor (let i = 0; i < cols.length; i++)\n\t\t\tbuf[i].push(row[i]);\n\t};\n\n\tfunction gen(accInit, accAppend, genConvertRow) {\n\t\tlet convertRow = null;\n\n\t\treturn (csvStr, cb = accum) => {\n\t\t\tconvertRow ??= genConvertRow();\n\n\t\t\tlet _skip = buf == null ? skip : 0;\n\n\t\t\tbuf ??= accInit();\n\t\t\tlet out = buf;\n\t\t\tlet withEOF = streamState === 0 || streamState === 2;\n\n\t\t\tlet halted = false;\n\n\t\t\tif (Array.isArray(csvStr)) {\n\t\t\t\tfor (let i = 0; i < csvStr.length; i++) {\n\t\t\t\t\tlet row = csvStr[i];\n\t\t\t\t\tlet res = cb(convertRow(row), out, accAppend);\n\n\t\t\t\t\tif (res === false) {\n\t\t\t\t\t\thalted = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\t[prevUnparsed, halted] = parse(csvStr, schema, _skip, row => cb(convertRow(row), out, accAppend), withEOF);\n\n\t\t\tif (halted && streamState !== 0)\n\t\t\t\treset();\n\n\t\t\tif (withEOF)\n\t\t\t\tbuf = null;\n\n\t\t\treturn out;\n\t\t};\n\t}\n\n\tconst _toStrGen = () => {\n\t\t_toStr ??= row => row;\n\t\treturn _toStr;\t};\n\n\tconst _toArrGen = () => {\n\t\t_toArr ??= genToTypedRow(cols, false, false);\n\t\treturn _toArr;\n\t};\n\n\tconst stringArrs = gen(initRows, addRow, _toStrGen);\n\n\tconst stringObjs = gen(initRows, addRow, () => {\n\t\t_toObjS ??= genToTypedRow(cols.map(col => ({\n\t\t\t...col,\n\t\t\ttype: 's',\n\t\t\trepl: {\n\t\t\t\t...col.repl,\n\t\t\t\tempty: void 0,\n\t\t\t}\n\t\t})), true, false);\n\n\t\treturn _toObjS;\n\t});\n\n\tconst typedArrs = gen(initRows, addRow, _toArrGen);\n\n\tconst typedObjs = gen(initRows, addRow, () => {\n\t\t_toObj ??= genToTypedRow(cols, true, false);\n\t\treturn _toObj;\n\t});\n\n\tconst typedDeep = gen(initRows, addRow, () => {\n\t\t_toDeep ??= genToTypedRow(cols, true, true);\n\t\treturn _toDeep;\n\t});\n\n\tconst typedCols = gen(initCols, addCol, _toArrGen);\n\n\tconst stringCols = gen(initCols, addCol, _toStrGen);\n\n\treturn {\n\t\tschema,\n\n\t\tstringArrs,\n\t\tstringObjs,\n\t\tstringCols,\n\n\t\ttypedArrs,\n\t\ttypedObjs,\n\t\ttypedDeep,\n\t\ttypedCols,\n\n\t\tchunk(csvStr, parse = stringArrs, cb = accum) {\n\t\t\tstreamParse ??= parse;\n\t\t\tstreamCb    ??= cb;\n\n\t\t\tstreamState = 1;\n\t\t\tstreamParse(prevUnparsed + csvStr, streamCb);\n\t\t},\n\t\tend() {\n\t\t\tstreamState = 2;\n\t\t\tlet out = streamParse(prevUnparsed, streamCb);\n\t\t\treset();\n\t\t\treturn out;\n\t\t},\n\t};\n}\n\n// todo: allow schema to have col.skip: true\n// _maxCols is cols estimated by simple delimiter detection and split()\n// returns [unparsed tail, shouldHalt]\nfunction parse(csvStr, schema, skip = 0, each = () => true, withEOF = true, _maxCols) {\n\tcsvStr = stripBOM(csvStr);\n\n\tlet {\n\t\trow:  rowDelim,\n\t\tcol:  colDelim,\n\t\tencl: colEncl,\n\t\tesc:  escEncl,\n\t\ttrim,\n\t} = schema;\n\n\t// is this cheap in WebKit/Mozilla, would simplify exit conditions\n\t// if (withEOF && !csvStr.endsWith(rowDelim))\n\t// \tcsvStr += rowDelim;\n\n\tcolEncl ??= csvStr.indexOf(quote) > -1 ? quote : ''; \t// TODO: detect single quotes?\n\tescEncl ??= colEncl;\n\n\tlet replEsc = `${escEncl}${colEncl}`;\n\n\tlet numCols = _maxCols ?? schema.cols.length;\n\n\t// uses a slower regexp path for schema probing\n\tlet _probe = _maxCols != null;\n\n\tlet rowDelimLen = rowDelim.length;\n\tlet colDelimLen = colDelim.length;\n\n\tlet colEnclChar  = colEncl.charCodeAt(0);\n\tlet escEnclChar  = escEncl.charCodeAt(0);\n\tlet rowDelimChar = rowDelim.charCodeAt(0);\n\tlet colDelimChar = colDelim.charCodeAt(0);\n\tlet spaceChar    = 32;\n\n\tlet out = ['', false];\n\n\tlet pos = 0;\n\tlet endPos = csvStr.length - 1;\n\tlet linePos = 0;\n\n\tlet rowTpl = Array(numCols).fill('');\n\tlet row = rowTpl.slice();\n\n\tlet colIdx = 0;\n\tlet lastColIdx = numCols - 1;\n\tlet filledColIdx = -1;\n\n\tif (colEncl === '') {\n\t\twhile (pos <= endPos) {\n\t\t\tif (colIdx === lastColIdx) {\n\t\t\t\tlet pos2 = csvStr.indexOf(rowDelim, pos);\n\n\t\t\t\tif (pos2 === -1) {\n\t\t\t\t\tif (!withEOF)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tpos2 = endPos + 1;\n\t\t\t\t}\n\n\t\t\t\tlet s = csvStr.slice(pos, pos2);\n\t\t\t\trow[colIdx] = trim ? s.trim() : s;\n\n\t\t\t\tif (--skip < 0) {\n\t\t\t\t\tif (each(row) === false) {\n\t\t\t\t\t\t// if caller indicates an early exit, we dont return the unparsed tail\n\t\t\t\t\t\tout[1] = true;\n\t\t\t\t\t\treturn out;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trow = rowTpl.slice();\n\t\t\t\tcolIdx = 0;\n\t\t\t\tfilledColIdx = -1;\n\t\t\t\tpos = pos2 + rowDelimLen;\n\t\t\t\tlinePos = pos;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// empty line\n\t\t\t\tif (colIdx === 0 && csvStr.charCodeAt(pos) === rowDelimChar) {\n\t\t\t\t\tpos += rowDelimLen;\n\t\t\t\t\t// TODO: callback here!\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlet pos2 = csvStr.indexOf(colDelim, pos);\n\n\t\t\t\t\tif (pos2 === -1) {\n\t\t\t\t\t\tif (!withEOF)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet s = csvStr.slice(pos, pos2);\n\t\t\t\t\trow[colIdx] = trim ? s.trim() : s;\n\t\t\t\t\tpos = pos2 + colDelimLen;\n\t\t\t\t\tfilledColIdx = colIdx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (--skip < 0 && withEOF && colIdx === lastColIdx && filledColIdx > -1)\n\t\t\teach(row);\n\n\t\tout[0] = !withEOF ? csvStr.slice(linePos) : '';\n\t\treturn out;\n\t}\n\n\t// should this be * to handle ,, ?\n\tconst takeToCommaOrEOL = _probe ? new RegExp(`[^${colDelim}${rowDelim}]+`, 'my') : null;\n\n\t// 0 = no\n\t// 1 = unquoted\n\t// 2 = quoted\n\tlet inCol = 0;\n\n\tlet v = '';\n\tlet c = 0;\n\n\tlet pos0 = pos;\n\n\twhile (pos <= endPos) {\n\t\tc = csvStr.charCodeAt(pos);\n\n\t\tif (inCol === 0) {\n\t\t\tif (c === colEnclChar) {\n\t\t\t\tinCol = 2;\n\t\t\t\tpos += 1;\n\t\t\t\tpos0 = pos;\n\n\t\t\t\tif (pos > endPos)\n\t\t\t\t\tbreak;\n\n\t\t\t\tc = csvStr.charCodeAt(pos);\n\t\t\t}\n\t\t\telse if (c === colDelimChar || c === rowDelimChar) {\n\t\t\t\t// PUSH MACRO START\n\t\t\t\tif (c === rowDelimChar && colIdx === 0) {\n\t\t\t\t\tpos += rowDelimLen;\n\t\t\t\t\t// TODO: callback here!\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\trow[colIdx] = v;\n\t\t\t\tfilledColIdx = colIdx;\n\t\t\t\tcolIdx += 1;\n\n\t\t\t\tpos += 1;\n\t\t\t\tv = '';\n\n\t\t\t\tif (c === rowDelimChar) {\n\t\t\t\t\tif (_probe && filledColIdx < lastColIdx && linePos === 0) {\n\t\t\t\t\t\trow.length = rowTpl.length = filledColIdx + 1;\n\t\t\t\t\t\tlastColIdx = filledColIdx;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (--skip < 0) {\n\t\t\t\t\t\tif (each(row) === false) {\n\t\t\t\t\t\t\t// if caller indicates an early exit, we dont return the unparsed tail\n\t\t\t\t\t\t\tout[1] = true;\n\t\t\t\t\t\t\treturn out;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\trow = rowTpl.slice();\n\t\t\t\t\tcolIdx = 0;\n\t\t\t\t\tfilledColIdx = -1;\n\t\t\t\t\tpos += rowDelimLen - 1;\n\t\t\t\t\tlinePos = pos;\n\t\t\t\t}\n\t\t\t\t// PUSH MACRO END\n\n\t\t\t\tif (pos > endPos)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (trim && c === spaceChar) {\n\t\t\t\t\twhile (c === spaceChar)\n\t\t\t\t\t\tc = csvStr.charCodeAt(++pos);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tinCol = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (inCol === 2) {\n\t\t\tlet shouldRep = false;\n\t\t\tlet posTo = 0;\n\n\t\t\twhile (true) {\n\t\t\t\tif (c === colEnclChar) {\n\t\t\t\t\tif (colEnclChar === escEnclChar) {\n\t\t\t\t\t\tif (pos + 1 > endPos) { // TODO: test with chunk ending in closing \", even at EOL but not EOF\n\t\t\t\t\t\t\tposTo = pos;\n\t\t\t\t\t\t\tpos = endPos + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet cNext = csvStr.charCodeAt(pos + 1);\n\n\t\t\t\t\t\tif (cNext === colEnclChar) {\n\t\t\t\t\t\t\tpos += 2;\n\n\t\t\t\t\t\t\t// MACRO START\n\t\t\t\t\t\t\tshouldRep = true;\n\t\t\t\t\t\t\tif (pos > endPos)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tc = csvStr.charCodeAt(pos);\n\t\t\t\t\t\t\t// MACRO END\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tinCol = 0;\n\t\t\t\t\t\t\tposTo = pos;\n\t\t\t\t\t\t\tpos += 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet cPrev = csvStr.charCodeAt(pos - 1);\n\n\t\t\t\t\t\tif (cPrev === escEnclChar) {\n\t\t\t\t\t\t\tpos += 1;\n\n\t\t\t\t\t\t\t// MACRO START\n\t\t\t\t\t\t\tshouldRep = true;\n\t\t\t\t\t\t\tif (pos > endPos)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tc = csvStr.charCodeAt(pos);\n\t\t\t\t\t\t\t// MACRO END\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tinCol = 0;\n\t\t\t\t\t\t\tposTo = pos;\n\t\t\t\t\t\t\tpos += 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlet pos2 = csvStr.indexOf(colEncl, pos);\n\n\t\t\t\t\tif (pos2 === -1) {\n\t\t\t\t\t\tpos = endPos + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tpos = pos2;\n\t\t\t\t\tc = colEnclChar;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (inCol === 0 || pos > endPos) {\n\t\t\t\tv = shouldRep ?\n\t\t\t\t\tcsvStr.slice(pos0, posTo).replaceAll(replEsc, colEncl) :\n\t\t\t\t\tcsvStr.slice(pos0, posTo);\n\t\t\t}\n\t\t}\n\t\telse if (inCol === 1) {\n\t\t\tif (c === colDelimChar || c === rowDelimChar) {\n\t\t\t\t// PUSH MACRO START\n\t\t\t\tif (c === rowDelimChar && colIdx === 0) {\n\t\t\t\t\tpos += rowDelimLen;\n\t\t\t\t\t// TODO: callback here!\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\trow[colIdx] = v;\n\t\t\t\tfilledColIdx = colIdx;\n\t\t\t\tcolIdx += 1;\n\n\t\t\t\tpos += 1;\n\t\t\t\tv = '';\n\n\t\t\t\tif (c === rowDelimChar) {\n\t\t\t\t\tif (_probe && filledColIdx < lastColIdx && linePos === 0) {\n\t\t\t\t\t\trow.length = rowTpl.length = filledColIdx + 1;\n\t\t\t\t\t\tlastColIdx = filledColIdx;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (--skip < 0) {\n\t\t\t\t\t\tif (each(row) === false) {\n\t\t\t\t\t\t\t// if caller indicates an early exit, we dont return the unparsed tail\n\t\t\t\t\t\t\tout[1] = true;\n\t\t\t\t\t\t\treturn out;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\trow = rowTpl.slice();\n\t\t\t\t\tcolIdx = 0;\n\t\t\t\t\tfilledColIdx = -1;\n\t\t\t\t\tpos += rowDelimLen - 1;\n\t\t\t\t\tlinePos = pos;\n\t\t\t\t}\n\t\t\t\t// PUSH MACRO END\n\n\t\t\t\tinCol = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (_probe) {\n\t\t\t\t\ttakeToCommaOrEOL.lastIndex = pos;\n\t\t\t\t\tlet m = takeToCommaOrEOL.exec(csvStr)[0];\n\t\t\t\t\tv = m;\n\t\t\t\t\tpos += m.length;  // rowdelim when - 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlet pos2 = csvStr.indexOf(colIdx === lastColIdx ? rowDelim : colDelim, pos);\n\n\t\t\t\t\tif (pos2 === -1)\n\t\t\t\t\t\tpos2 = endPos + 1;\n\n\t\t\t\t\tlet s = csvStr.slice(pos, pos2);\n\t\t\t\t\tv = trim ? s.trim() : s;\n\t\t\t\t\tpos = pos2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (withEOF && colIdx === lastColIdx) {\n\t\trow[colIdx] = v;\n\n\t\tif (--skip < 0)\n\t\t\teach(row);\n\n\t\tinCol = 0;\n\t}\n\n\tlet partial = !withEOF && (\n\t\tinCol !== 0 ||\n\t\t(\n\t\t\tfilledColIdx === -1 ? v !== '' :  // partial first col OR\n\t\t\tfilledColIdx < lastColIdx         // not all cols filled\n\t\t)\n\t);\n\n\tout[0] = partial ? csvStr.slice(linePos) : '';\n\treturn out;\n}\n\n// const parsed = {\n// \tformat: '',\n// \tdata: []\n// };\n\nexport { inferSchema, initParser };\n",null,null,"import { invalidate } from \"./core.js\";\n/**\n * Creates a memoized function.\n *\n * @example\n *\n *     const Example = component((c) => {\n *       const fullName = useMemo(shallowEqArray, ([firstName, lastName]) => (\n *         `${firstName} ${lastName}`\n *       ));\n *\n *       return ({firstName, lastName}) => html`\n *         div.fullName ${fullName([firstName, lastName])}\n *       `;\n *     });\n *\n * @typeparam T Input type.\n * @typeparam U Output type.\n * @param areEqual Function that checks if input value hasn't changed.\n * @param fn Function to memoize.\n * @returns Memoized function.\n */\nexport const useMemo = (areEqual, fn) => {\n    var prev;\n    var v;\n    return (props) => ((v === void 0 || areEqual(prev, props) === false)\n        ? v = fn(prev = props)\n        : v);\n};\n/**\n * Creates a reactive state.\n *\n * @example\n *\n *     const Example = component((c) => {\n *       const [getCounter, setCounter] = useState(c, 0);\n *       const inc = () => { setCounter(getCounter() + 1); };\n *\n *       return () => html`\n *         div.app\n *           div.counter ${getCounter()}\n *           button @click=${inc} 'Increment'\n *       `;\n *     });\n *\n * @typeparam S State type.\n * @param component Component instance.\n * @param state Initial state value.\n * @returns A tuple with a getter and setter functions.\n */\nexport const useState = (component, state) => ([\n    // getter\n    () => state,\n    // setter\n    (next) => {\n        if (next !== state) {\n            state = next;\n            invalidate(component);\n        }\n    }\n]);\n/**\n * Creates a reactive state reducer.\n *\n * @example\n *\n *     function reducer(state, action) {\n *       switch (action.type) {\n *         case \"inc\":\n *           return state + 1;\n *       }\n *       return state;\n *     }\n *\n *     const Example = component((c) => {\n *        const [counter, dispatch] = useReducer(c, 0, reducer);\n *        const inc = () => { dispatch(\"inc\"); };\n *\n *       return () => html`\n *         div.app\n *           div.counter ${counter()}\n *           button @click=${inc} 'Increment'\n *       `;\n *     });\n *\n * @typeparam S State type.\n * @typeparam A Reducer action type.\n * @param component Component instance.\n * @param state Initial state.\n * @param reducer Reducer function.\n * @returns State getter and dispatch functions.\n */\nexport const useReducer = (component, state, reducer) => ([\n    () => state,\n    (action) => {\n        const nextState = reducer(state, action);\n        if (state !== nextState) {\n            state = nextState;\n            invalidate(component);\n        }\n        return state;\n    }\n]);\n//# sourceMappingURL=state.js.map"],"names":["d","EMPTY_ARRAY","__IVI_STRINGS__","_Object","Object","_Array","Array","_isArray","isArray","_Map","Map","_Int32Array","Int32Array","_queueMicrotask","queueMicrotask","nodeProto","Node","prototype","elementProto","Element","doc","document","HTM_TEMPLATE","createElement","HTM_TEMPLATE_CONTENT","content","_SVG_TEMPLATE","SVG_TEMPLATE","createElementNS","appendChild","firstChild","nodeInsertBefore","insertBefore","nodeRemoveChild","removeChild","nodeCloneNode","cloneNode","elementSetAttribute","setAttribute","elementRemoveAttribute","removeAttribute","elementAddEventListener","addEventListener","elementRemoveEventListener","removeEventListener","getDescriptor","o","p","getOwnPropertyDescriptor","nodeGetFirstChild","get","nodeGetNextSibling","nodeSetTextContent","set","elementSetInnerHTML","elementSetClassName","htmlElementGetStyle","HTMLElement","svgElementGetStyle","SVGElement","RENDER_CONTEXT","seal","n","si","e","createSNode","f","v","c","s1","_flushDOMEffects","length","i","_updateTemplateProperties","currentElement","opCodes","data","state","prevProps","nextProps","svg","style","op","type","dataIndex","propsIndex","next","key","prev","call","nodeValue","setProperty","removeProperty","_assignTemplateSlots","currentNode","offset","endOffset","ctx","enterOffset","commentNode","remove","_mountList","parentState","flags","children","vNode","sChildren","sNode","_mount","_update","parentSNode","updateFlags","_unmount","_dirtyCheck","_updateArray","prevSChildren","nextSChildren","prevLength","nextLength","sChild","descriptor","p2","parentElement","tplData","p1","propsOpCodes","childOpCodes","rootDOMNode","childrenIndex","childOpCode","value","_updateList","props","descriptorP1","parentDOMElement","nextDOMNode","stateOpCodes","s","s2","renderFn","createTextNode","detach","unmountHooks","a","b","aKeys","k","bKeys","bVNodes","bLength","aLength","result","aEnd","bEnd","start","outer","sources","keyIndex","j","nodePosition","nextPosition","markLIS","node","lisValue","lo","hi","parent","index","indexLength","_h","t","innerHTML","_T","_t","component","getProps","invalidate","LIST_DESCRIPTOR","_dirtyCheckRoot","root","domSlot","createRoot","cleanRHS","JSON","stringify","EMPTY_OBJ","OPTS","chain","ops","cmp","Intl","Collator","numeric","sensitivity","compare","haltEvent","preventDefault","stopPropagation","stopImmediatePropagation","onWinCap","fn","window","capture","offWinCap","__ivi_hoist_1","col","__ivi_1._t","__ivi_tpl_2","Table","hook","reset","pending","dom","setDom","el","table","cols","schema","filts","map","ci","sortDir","fill","sortPos","dataFilt","dataSort","reFilt","nonEmpty","compileMatcherStringTuples","rules","filter","r","compileFilter","nodes","opts","_compileFilter","useIdx","expr","stmts","compileExpr","lhs","rhs","negate","slice","$ops","test","push","path","cleanLHS","cleanPath","replace","exprs","node2","join","min","max","l","at","Function","flatMap","reSort","sortFn","compileSorterTuples","pos","dir","simple","sorts","sort","body","scrollTop","rowHgt","chunkLen","Math","idx0","colWids","setIdx0","force","idx1","floor","num","useEffect","resizeObserver","ResizeObserver","sync","rFull","getBoundingClientRect","rThead","querySelector","viewHgt","height","rTbody","tbody","colEl","querySelectorAll","val","width","viewRows","observe","unobserve","disconnect","useUnmount","hooks","onClicks","onClickCol","idx","shiftKey","onChangeFiltOps","target","onChangeFiltVals","onDowns","button","fromX","clientX","fromWid","onMove","newWid","onClick","row","__ivi_tpl_1","Cell","Row","__ivi_hoist_2","gridTplCols","getKey","chunk","totalHgt","padTop","padBtm","__ivi_tpl_6","__ivi_tpl_4","name","__ivi_tpl_3","__ivi_tpl_5","entries","ISO8601","BOOL_RE","COL_DELIMS","stripBOM","str","charCodeAt","toJSON","onlyStrEsc","getValParseExpr","parse","rv","parseExpr","repl","nanExpr","NaN","nullExpr","null","emptyExpr","empty","segsRe","genToTypedRow","objs","deep","buf","tplObj","colIdx","paths","shift","segs","matchAll","m","seg","endChar","nextNode","every","forEach","parseVal","csvStr","skip","each","withEOF","_maxCols","rowDelim","colDelim","encl","colEncl","esc","escEncl","trim","indexOf","replEsc","numCols","_probe","rowDelimLen","colDelimLen","colEnclChar","escEnclChar","rowDelimChar","colDelimChar","out","endPos","linePos","rowTpl","lastColIdx","filledColIdx","pos2","takeToCommaOrEOL","RegExp","inCol","pos0","shouldRep","posTo","cNext","cPrev","replaceAll","lastIndex","exec","partial","CSVDropper","onDrop","item","dataTransfer","items","kind","file","getAsFile","endsWith","text","then","console","time","inferSchema","maxRows","header","headerFn","firstRows","rowRE","firstRowMatch","match","firstRowStr","find","delim","split","headerRows","colNames","keys","splice","colName","guessType","rows","findLast","T_BOOLEAN","boolTrue","c0","c1","isJSON","initParser","_toStr","_toArr","_toObj","_toDeep","_toObjS","streamState","streamParse","streamCb","prevUnparsed","accum","add","initRows","initCols","addRow","addCol","gen","accInit","accAppend","genConvertRow","convertRow","cb","_skip","halted","res","_toStrGen","_toArrGen","stringArrs","stringObjs","typedArrs","typedObjs","typedDeep","typedCols","stringCols","end","timeEnd","setData","onDragOver","App","getData","update","forceUpdate"],"mappings":"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","x_google_ignoreList":[0,1,4,7]}